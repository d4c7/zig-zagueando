[{"content":"Â¡Bienvenido al emocionante mundo de Zig! ğŸš€ Si estÃ¡s buscando un lenguaje de programaciÃ³n que combine eficiencia, seguridad y un enfoque en el rendimiento, Â¡has llegado al lugar correcto!\nÂ¿Por quÃ© Zig? ğŸ¯ Una de las primeras cosas que notarÃ¡s al explorar Zig es su enfoque en la seguridad y la prevenciÃ³n de errores. El compilador de Zig es estricto y te ayudarÃ¡ a detectar problemas en tiempo de compilaciÃ³n antes de que se conviertan en pesadillas en tiempo de ejecuciÃ³n. Esto no solo te brinda una mayor confianza en la calidad de tu cÃ³digo, sino que tambiÃ©n te enseÃ±a buenas prÃ¡cticas para evitar errores comunes.\nPero Zig no se detiene solo en la seguridad. Si te apasiona la programaciÃ³n de alto rendimiento y quieres escribir cÃ³digo que aproveche al mÃ¡ximo los recursos del sistema, Zig es el lenguaje adecuado para ti. Su sintaxis limpia y elegante te permite escribir cÃ³digo eficiente y optimizado sin sacrificar la legibilidad.\nAdemÃ¡s, aprender Zig te brinda la oportunidad de adentrarte en el mundo de la programaciÃ³n de bajo nivel. Con Zig, puedes acceder directamente a la memoria y tener un control preciso sobre los recursos del sistema. Esto es especialmente Ãºtil si estÃ¡s interesado en desarrollar aplicaciones de sistemas embebidos, controladores de dispositivos o soluciones de bajo nivel.\nZig tambiÃ©n es una excelente opciÃ³n para aquellos que estÃ¡n aprendiendo a programar. A travÃ©s de Zig, puedes adquirir una comprensiÃ³n sÃ³lida de los conceptos fundamentales de la programaciÃ³n, como el control de flujo, las estructuras de datos y los algoritmos. Al mismo tiempo, ampliarÃ¡s tu perspectiva sobre la programaciÃ³n y desarrollarÃ¡s habilidades valiosas para el futuro.\nNo te voy a engaÃ±ar: Zig a veces muerde ğŸ˜¬, pero eso es bueno. Es un lenguage en plena creaciÃ³n y evoluciona muy rÃ¡pidamente con cambios incompatibles y bugs. AdemÃ¡s su determinado enfoque en la seguridad te obliga a ser consciente de muchos aspectos que en otros lenguages simplemente se ignoran (el precio se paga despuÃ©s). Pero no temas programador, Â¡todo eso te harÃ¡ mas fuerte!.ğŸ’ª\nÂ¡Hola, mundo! ğŸ‘‹ Como en cualquier lenguaje, el primer paso es escribir un clÃ¡sico \u0026ldquo;Hola, mundo\u0026rdquo; en Zig para ver quÃ© pinta tiene y quÃ© sensaciones te produce:\nâš ï¸ Â¡AtenciÃ³n, programador! Este post utiliza la versiÃ³n dev 0.11.0 de Zig\n1 2 3 4 5 6 7 8 9 10 //zig version: 0.11.0-dev.3191+fd213accb const std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { const stdout = std.io.getStdOut().writer(); try stdout.print(\u0026#34;Â¡Hola, mundo!\\n\u0026#34;,.{}); } Es muy poco cÃ³digo pero ya se pueden observar algunas caracterÃ­sticas del lenguaje Zig:\nEnfoque en la seguridad: El uso de la declaraciÃ³n try para manejar errores de manera explÃ­cita demuestra la preocupaciÃ³n por la seguridad y la prevenciÃ³n de errores en Zig.\nSintaxis limpia y legible: La sintaxis del programa es clara y fÃ¡cil de entender, lo que facilita la lectura y escritura de cÃ³digo en Zig.\nManejo explÃ­cito de recursos: Al obtener el escritor de salida estÃ¡ndar a travÃ©s de getStdOut(), Zig enfatiza el manejo explÃ­cito de recursos, permitiendo un control mÃ¡s preciso y seguro.\nOrientaciÃ³n a bajo nivel: Zig permite acceder directamente a la memoria y proporciona un mayor control sobre los recursos del sistema, lo que es Ãºtil en situaciones de programaciÃ³n de bajo nivel.\nEnfoque en el rendimiento: Zig estÃ¡ diseÃ±ado para ofrecer un rendimiento excepcional, lo que se refleja en la eficiencia del programa \u0026ldquo;Hello, World\u0026rdquo;.\nEstas cualidades son solo una pequeÃ±a muestra de las fortalezas de Zig como lenguaje de programaciÃ³n. A medida que te adentres en Zig, descubrirÃ¡s muchas mÃ¡s ventajas que te ayudarÃ¡n a desarrollar software eficiente y confiable.\nOtro ejemplo, un poco mÃ¡s completo, tiene esta pinta:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 //zig version: 0.11.0-dev.3191+fd213accb const std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { // Prints to stderr (it\u0026#39;s a shortcut based on `std.io.getStdErr()`) std.debug.print(\u0026#34;All your {s} are belong to us.\\n\u0026#34;, .{\u0026#34;codebase\u0026#34;}); // stdout is for the actual output of your application, for example if you // are implementing gzip, then only the compressed bytes should be sent to // stdout, not any debugging messages. const stdout_file = std.io.getStdOut().writer(); var bw = std.io.bufferedWriter(stdout_file); const stdout = bw.writer(); try stdout.print(\u0026#34;Run `zig build test` to run the tests.\\n\u0026#34;, .{}); try bw.flush(); // don\u0026#39;t forget to flush! } test \u0026#34;simple test\u0026#34; { var list = std.ArrayList(i32).init(std.testing.allocator); defer list.deinit(); // try commenting this out and see if zig detects the memory leak! try list.append(42); try std.testing.expectEqual(@as(i32, 42), list.pop()); } Me gusta, Â¿CÃ³mo aprendo? ğŸ“šğŸ’¡ La documentaciÃ³n oficial de Zig es un excelente punto de partida. Puedes acceder a ella en el sitio web oficial de Zig y encontrarÃ¡s una guÃ­a detallada, ejemplos de cÃ³digo, tutoriales y una descripciÃ³n completa de la biblioteca estÃ¡ndar. La documentaciÃ³n oficial es constantemente actualizada y es una fuente confiable para comprender la sintaxis, las caracterÃ­sticas del lenguaje y las mejores prÃ¡cticas. Recuerda, consulta siempre la documentaciÃ³n de la versiÃ³n de Zig que estÃ©s utilizando, porque puede variar mucho de una a otra.\nEl repositorio oficial de Zig en GitHub es una fuente invaluable de cÃ³digo fuente abierto en Zig. Puedes explorar proyectos de la comunidad, estudiar el cÃ³digo existente y aprender de ejemplos prÃ¡cticos. TambiÃ©n puedes contribuir a proyectos existentes o incluso iniciar tus propios proyectos en Zig.\nAdemÃ¡s de GitHub, el subreddit de Zig y el canal de Discord oficial de Zig son excelentes lugares para conectarte con otros programadores de Zig, hacer preguntas, compartir conocimientos y obtener ayuda. Estos espacios de la comunidad estÃ¡n llenos de personas amigables y conocedoras que estÃ¡n dispuestas a ayudarte en tu viaje de aprendizaje en Zig.\nRecuerda que la prÃ¡ctica es fundamental para dominar cualquier lenguaje de programaciÃ³n. A medida que adquieras conocimientos, te recomiendo implementar proyectos pequeÃ±os y desafiantes por tu cuenta. Esto te permitirÃ¡ aplicar lo que has aprendido, experimentar con difer\nY por supuesto Â¡sigue este blog!. Te llevarÃ© a un emocionante viaje a travÃ©s del mundo de Zig. CompartirÃ© tutoriales, consejos Ãºtiles, trucos y experiencias personales mientras exploramos juntos las maravillas y desafÃ­os de este increÃ­ble lenguaje de programaciÃ³n. Desde los conceptos bÃ¡sicos hasta tÃ©cnicas avanzadas, encontrarÃ¡s contenido fresco y relevante para mejorar tus habilidades en Zig.\nAhora empieza todo Â¡No te pierdas ninguno de los nuevos artÃ­culos de \u0026ldquo;Zig-zagueando\u0026rdquo;! Puedes suscribirte al blog mediante el clÃ¡sico y eficiente RSS ğŸ“° para recibir notificaciones cada vez que publique una nueva entrada. AdemÃ¡s, te invito a participar en los comentarios, compartir tus propias experiencias y hacer preguntas sobre cualquier tema relacionado con Zig.\nÂ¡PrepÃ¡rate para disfrutar de un blog lleno de conocimientos, diversiÃ³n y aventuras en Zig! Â¡Nos vemos, valiente programador!\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/zig-un-lenguaje-de-programaci%C3%B3n-simple-y-potente/","summary":"Â¡Bienvenido al emocionante mundo de Zig! ğŸš€ Si estÃ¡s buscando un lenguaje de programaciÃ³n que combine eficiencia, seguridad y un enfoque en el rendimiento, Â¡has llegado al lugar correcto!\nÂ¿Por quÃ© Zig? ğŸ¯ Una de las primeras cosas que notarÃ¡s al explorar Zig es su enfoque en la seguridad y la prevenciÃ³n de errores. El compilador de Zig es estricto y te ayudarÃ¡ a detectar problemas en tiempo de compilaciÃ³n antes de que se conviertan en pesadillas en tiempo de ejecuciÃ³n.","title":"Zig: Un lenguaje de programaciÃ³n simple y potente ğŸš€"},{"content":"Â¡Hola, entusiastas de Zig! ğŸ‘‹ En la publicaciÃ³n anteriores hemos visto que Zig mola mucho. Pero antes de sumergirnos en temas mÃ¡s avanzados, vamos a asegurarnos de tener Zig instalado y funcionando en nuestros sistemas. En esta publicaciÃ³n, te guiarÃ© en la instalaciÃ³n de Zig en Linux, Windows y macOS. Â¡Comencemos! ğŸš€\nInstalando Zig en Linux ğŸ§ âš ï¸ Â¡AtenciÃ³n, programador! Este post utiliza la versiÃ³n dev 0.11.0 de Zig\nPara usuarios de Linux, puedes instalar Zig utilizando los paquetes precompilados o construyÃ©ndolo desde el cÃ³digo fuente.\nPaquetes precompilados: Descarga el paquete apropiado para tu distribuciÃ³n de Linux desde la pÃ¡gina oficial de descargas de Zig. Extrae el archivo y agrega el binario zig a tu PATH.\nConstruir desde el cÃ³digo fuente: Si prefieres construir Zig desde el cÃ³digo fuente, sigue estos pasos:\nInstala las dependencias necesarias: build-essential, cmake y git. Clona el repositorio de Zig: git clone https://github.com/ziglang/zig.git Cambia al directorio clonado: cd zig Crea un directorio de construcciÃ³n: mkdir build \u0026amp;\u0026amp; cd build Ejecuta CMake para configurar la construcciÃ³n: cmake .. Construye Zig: make Agrega el binario zig a tu PATH. Una forma alternativa es usar snap: snap install --edge zig --classic\nInstalando Zig en Windows ğŸ’» Para usuarios de Windows, puedes instalar Zig utilizando los paquetes precompilados o el administrador de paquetes Scoop.\nPaquetes precompilados: Descarga el paquete apropiado para tu sistema desde la pÃ¡gina oficial de descargas de Zig. Extrae el archivo y agrega el binario zig a tu PATH.\nScoop: Si tienes Scoop instalado, puedes instalar Zig ejecutando: scoop install zig\nInstalando Zig en macOS ğŸ Para usuarios de macOS, puedes instalar Zig utilizando los paquetes precompilados, Homebrew o MacPorts.\nPaquetes precompilados: Descarga el paquete apropiado para tu sistema desde la pÃ¡gina oficial de descargas de Zig. Extrae el archivo y agrega el binario zig a tu PATH.\nHomebrew: Si tienes Homebrew instalado, puedes instalar Zig ejecutando: brew install zig\nMacPorts: Si tienes MacPorts instalado, puedes instalar Zig ejecutando: sudo port install zig\nÂ¡Listo! Ahora deberÃ­as tener Zig instalado en tu sistema Linux, Windows o macOS. ğŸ‰\nÂ¿QuÃ© mÃ¡s? ğŸŒŸ Con Zig instalado, estÃ¡s listo para explorar temas mÃ¡s avanzados y aprovechar todo el potencial de este emocionante lenguaje.\nÂ¡Ãnimo programador!\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/instalando-zig-en-linux-windows-y-macos/","summary":"Â¡Hola, entusiastas de Zig! ğŸ‘‹ En la publicaciÃ³n anteriores hemos visto que Zig mola mucho. Pero antes de sumergirnos en temas mÃ¡s avanzados, vamos a asegurarnos de tener Zig instalado y funcionando en nuestros sistemas. En esta publicaciÃ³n, te guiarÃ© en la instalaciÃ³n de Zig en Linux, Windows y macOS. Â¡Comencemos! ğŸš€\nInstalando Zig en Linux ğŸ§ âš ï¸ Â¡AtenciÃ³n, programador! Este post utiliza la versiÃ³n dev 0.11.0 de Zig\nPara usuarios de Linux, puedes instalar Zig utilizando los paquetes precompilados o construyÃ©ndolo desde el cÃ³digo fuente.","title":"Instalando Zig en Linux, Windows y macOS ğŸŒ"},{"content":"Â¡Saludos, entusiastas de Zig! ğŸ‘‹ Es el momento de configurar un entorno de desarrollo cÃ³modo para mejorar tu experiencia de programaciÃ³n en Zig. En esta publicaciÃ³n, te guiarÃ© para configurar Visual Studio Code (VS Code) para el desarrollo en Zig, incluyendo ediciÃ³n de cÃ³digo, ejecuciÃ³n y depuraciÃ³n. Â¡SumÃ©rgete en el tema! ğŸš€\nConfigurando Visual Studio Code para el desarrollo en Zig ğŸ› ï¸ Para configurar VS Code para el desarrollo en Zig, sigue estos pasos:\nInstala Visual Studio Code: Si aÃºn no lo has hecho, descarga e instala Visual Studio Code para tu plataforma (Linux, Windows o macOS).\nInstala la extensiÃ³n de Zig: Abre el buscador rÃ¡pido de VS Code (Ctrl+P), pega el siguiente comando y presiona enter.\n1 ext install ziglang.vscode-zig Configura los ajustes: Para configurar los ajustes de la extensiÃ³n de Zig, abre el editor de ConfiguraciÃ³n haciendo clic en el Ã­cono de engranaje en la esquina inferior izquierda de la ventana y selecciona \u0026ldquo;ConfiguraciÃ³n\u0026rdquo;. Busca \u0026ldquo;Zig\u0026rdquo; en la barra de bÃºsqueda y actualiza los ajustes segÃºn sea necesario. Por ejemplo, es posible que desees establecer la ruta del compilador de Zig si no estÃ¡ en la ubicaciÃ³n predeterminada. Â¡Listo! Ahora estÃ¡s listo para desarrollar en Zig en VS Code. ğŸ‰\nEjecutando y depurando cÃ³digo ğŸƒâ€â™€ï¸ğŸ’» Para ejecutar y depurar cÃ³digo Zig en VS Code, sigue estos pasos:\nCrea un nuevo archivo Zig: Abre VS Code y crea un nuevo archivo con la extensiÃ³n .zig, como main.zig.\nEscribe cÃ³digo Zig: Escribe un programa sencillo en Zig en tu nuevo archivo, como un programa \u0026ldquo;Hola, mundo\u0026rdquo;:\nâš ï¸ Â¡AtenciÃ³n, programador! Este post utiliza la versiÃ³n dev 0.11.0 de Zig\n1 2 3 4 5 6 const std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { std.debug.print(\u0026#34;Hello, {s}!\\n\u0026#34;, .{\u0026#34;World\u0026#34;}); } Configura tasks.json: Para ejecutar tu cÃ³digo Zig, necesitas crear un archivo tasks.json en la carpeta .vscode de tu espacio de trabajo. Agrega la siguiente configuraciÃ³n al archivo: 1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;zig build-exe main.zig\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;build\u0026#34; } ] } Este archivo de configuraciÃ³n define tareas para Visual Studio Code. Las tareas se utilizan para automatizar el proceso de construcciÃ³n, prueba y despliegue de tu aplicaciÃ³n. En este caso, estamos definiendo la tarea de compilaciÃ³n:\n\u0026quot;label\u0026quot;: \u0026quot;build\u0026quot; - Es el nombre que se le da a la tarea. En este caso, la tarea se llama \u0026ldquo;build\u0026rdquo;. \u0026quot;type\u0026quot;: \u0026quot;shell\u0026quot; - Especifica que esta tarea se ejecutarÃ¡ en una shell o terminal. \u0026quot;command\u0026quot;: \u0026quot;zig build-exe main.zig\u0026quot; - Es el comando que se ejecutarÃ¡ cuando se inicie esta tarea. Este comando compilarÃ¡ el archivo main.zig en un ejecutable utilizando el compilador Zig. \u0026quot;group\u0026quot;: \u0026quot;build\u0026quot; - Esto agrupa la tarea en la categorÃ­a \u0026ldquo;build\u0026rdquo;. Las tareas se pueden agrupar para un fÃ¡cil acceso y gestiÃ³n en Visual Studio Code. Ejecuta tu cÃ³digo Zig: Presiona Ctrl+Shift+B (o Cmd+Shift+B en macOS) para ejecutar la tarea \u0026ldquo;build\u0026rdquo;, que compila tu cÃ³digo Zig. Salida:\n1 2 * Executing task: zig build-exe \u0026lt;...\u0026gt;/main.zig * Terminal will be reused by tasks, press any key to close it. DepuraciÃ³n: Para depurar tu cÃ³digo Zig, primero debes instalar las extensiones \u0026ldquo;Native Debug\u0026rdquo; de WebFreak y \u0026ldquo;CodeLLDB\u0026rdquo; de Vadim Chugunov. Presiona ctrl-p (cmd+p en macOS) y ejecuta los siguientes comandos:\n1 ext install webfreak.debug y\n1 ext install vadimcn.vscode-lldb Una vez instaladas, crea un archivo launch.json en la carpeta .vscode de tu espacio de trabajo con la siguiente configuraciÃ³n:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Debug Zig\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;lldb\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;main\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;preLaunchTask\u0026#34;: \u0026#34;build\u0026#34; } ] } Este archivo de configuraciÃ³n de lanzamiento se usa para definir cÃ³mo se debe depurar un proyecto. El campo configurations tiene una lista de diferentes configuraciones de depuraciÃ³n que puedes usar. Puedes cambiar entre estas configuraciones en el menÃº desplegable de depuraciÃ³n en la parte superior de VS Code. La configuraciÃ³n se define asÃ­:\nname: Es el nombre que aparece en el menÃº desplegable de depuraciÃ³n. En este caso, estÃ¡ configurado como \u0026ldquo;Debug Zig\u0026rdquo;, lo que indica que esta configuraciÃ³n es para depurar programas escritos en Zig. type: Define el depurador que se utilizarÃ¡. En este caso, \u0026ldquo;lldb\u0026rdquo; indica que se utilizarÃ¡ el depurador LLDB de LLVM. request: Puede ser \u0026ldquo;launch\u0026rdquo; o \u0026ldquo;attach\u0026rdquo;. \u0026ldquo;launch\u0026rdquo; inicia el programa en el depurador, mientras que \u0026ldquo;attach\u0026rdquo; se conecta a un proceso ya en ejecuciÃ³n. En la configuraciÃ³n el valor es \u0026ldquo;launch\u0026rdquo;, por lo que el depurador iniciarÃ¡ el programa. program: Es el nombre del programa que se va a iniciar. En esta configuraciÃ³n, el valor es \u0026ldquo;main\u0026rdquo;, por lo que se espera un ejecutable llamado \u0026ldquo;main\u0026rdquo; en tu directorio de trabajo actual. args: Es una lista de argumentos que se pasarÃ¡n al programa cuando se lance. En tu caso, esta lista estÃ¡ vacÃ­a, por lo que no se pasarÃ¡n argumentos. cwd: Especifica el directorio de trabajo actual cuando se inicia el programa. \u0026ldquo;${workspaceFolder}\u0026rdquo; es una variable que se refiere al directorio raÃ­z de tu espacio de trabajo actual en VS Code. preLaunchTask: Es el nombre de una tarea definida en tasks.json que se ejecutarÃ¡ antes de que se lance el programa. Este es solo un ejemplo de configuraciÃ³n de depuraciÃ³n. La configuraciÃ³n exacta puede variar segÃºn el lenguaje de programaciÃ³n y el entorno de desarrollo especÃ­ficos que estÃ©s utilizando.\nDepura tu cÃ³digo Zig: Establece puntos de interrupciÃ³n en tu cÃ³digo Zig haciendo clic en el margen izquierdo junto a los nÃºmeros de lÃ­nea. Presiona F5 para iniciar la depuraciÃ³n. El depurador se detendrÃ¡ en tus puntos de interrupciÃ³n, lo que te permitirÃ¡ inspeccionar variables, avanzar paso a paso en tu cÃ³digo y utilizar otras funciones de depuraciÃ³n. Â¡Eso es todo! Ahora has configurado Visual Studio Code para el desarrollo en Zig, incluyendo la ejecuciÃ³n, asistencia y depuraciÃ³n de tu cÃ³digo. ğŸ‰\nÂ¿QuÃ© mÃ¡s? ğŸŒŸ Con tu flamante entorno de desarrollo Zig, estÃ¡s listo para explorar temas avanzados de Zig y crear proyectos asombrosos. Â¡Mantente atento a mÃ¡s publicaciones en el blog sobre conceptos avanzados de Zig!\nÂ¡Sigamos explorando el mundo de Zig juntos! ğŸ‘©â€ğŸ’»ğŸ‘¨â€ğŸ’»ğŸ¨\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/configura-visual-studio-code-para-programar-en-zig/","summary":"Â¡Saludos, entusiastas de Zig! ğŸ‘‹ Es el momento de configurar un entorno de desarrollo cÃ³modo para mejorar tu experiencia de programaciÃ³n en Zig. En esta publicaciÃ³n, te guiarÃ© para configurar Visual Studio Code (VS Code) para el desarrollo en Zig, incluyendo ediciÃ³n de cÃ³digo, ejecuciÃ³n y depuraciÃ³n. Â¡SumÃ©rgete en el tema! ğŸš€\nConfigurando Visual Studio Code para el desarrollo en Zig ğŸ› ï¸ Para configurar VS Code para el desarrollo en Zig, sigue estos pasos:","title":"Configura Visual Studio Code para programar en Zig ğŸ¨"},{"content":"Â¡Hola, entusiastas de Zig! ğŸ‘‹ En nuestra publicaciÃ³n anterior, dimos nuestros primeros pasos en el mundo de Zig. Hoy, vamos a adentrarnos en el corazÃ³n de la gestiÃ³n de proyectos de Zig: el sistema de construcciÃ³n de Zig. Â¡Empecemos! ğŸ‰\nÂ¿QuÃ© es el sistema de construcciÃ³n de Zig? ğŸ¤” El sistema de construcciÃ³n de Zig es una herramienta poderosa e incorporada que te ayuda a gestionar, compilar, probar y enlazar tus proyectos. Simplifica procesos de construcciÃ³n complejos y proporciona una compilaciÃ³n cruzada sin interrupciones, permitiÃ©ndote apuntar a diferentes plataformas con facilidad.\nEmpezando con build.zig ğŸš€ Para aprovechar el sistema de construcciÃ³n de Zig, necesitas crear un archivo build.zig en el directorio raÃ­z de tu proyecto.\nEl conjunto de herramientas de Zig (toolchain) llama a la funciÃ³n build(b: *std.Build) void de build.zig. El parÃ¡metro bse utiliza para configurar y definir el proceso de construcciÃ³n mediante pasos o instrucciones que no formen ciclos o bucles.\nPor ejemplo, podemos crear nuestro propio paso my-step:\nâš ï¸ Â¡AtenciÃ³n, programador! Este post utiliza la versiÃ³n dev 0.11.0 de Zig\n1 2 3 4 5 6 7 const std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.build.Builder) void { const my_step = b.step(\u0026#34;my-step\u0026#34;, \u0026#34;Este paso es mi paso\u0026#34;); _ = my_step; } Este paso aparecerÃ¡ en la ayuda si ejecutamos zig build --help, y aunque no hace nada, hace mucha ilusiÃ³n.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 $ zig build --help Usage: zig build [steps] [options] Steps: install (default) Copy build artifacts to prefix path uninstall Remove build artifacts from prefix path my-step Este paso es mi paso [...] Project-Specific Options: (none) [...] TambiÃ©n podemos observar en la ayuda una secciÃ³n Project-Specific Options, que por ahora aparece vacÃ­a.\nAÃ±adiendo el primer paso ğŸ‘£ Zig viene equipado con algunos pasos listos para usar. Uno de los mÃ¡s interesantes es addExecutable, que permite compilar un ejecutable o librerÃ­a.\nSi aÃ±adimos este main.zig al directorio:\n1 2 3 4 5 6 7 8 const std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { const stdout = std.io.getStdOut().writer(); try stdout.print(\u0026#34;Hola otra vez\\n\u0026#34;, .{}); } Y definimos build.zig como:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.Build) void { const target = b.standardTargetOptions(.{}); const optimize = b.standardOptimizeOption(.{}); const exe = b.addExecutable(.{ .name = \u0026#34;my-executable\u0026#34;, .root_source_file = .{ .path = \u0026#34;main.zig\u0026#34; }, .target = target, .optimize = optimize, }); b.installArtifact(exe); } Cuando ejecutemos el comando zig build se compilarÃ¡ nuestro ejecutable. Estas son las lÃ­neas principales:\nconst target = b.standardTargetOptions(.{}): Define las opciones de destino que estarÃ¡n disponibles y cual serÃ¡ la de defecto, lo que permite al usuario seleccionar para quÃ© plataforma se va a construir el cÃ³digo.\nconst optimize = b.standardOptimizeOption(.{}): Define las opciones de optimizaciÃ³n estÃ¡ndar, lo que permite al usuario seleccionar el nivel de optimizaciÃ³n para la compilaciÃ³n.\nconst exe = b.addExecutable(.): AÃ±ade un ejecutable al proceso de construcciÃ³n. Los parÃ¡metros definen cÃ³mo se construirÃ¡ el ejecutable, incluyendo el archivo fuente principal, las opciones de destino y las opciones de optimizaciÃ³n.\nb.installArtifact(exe): Esta lÃ­nea declara que el ejecutable creado en el paso anterior debe ser instalado en la ubicaciÃ³n estÃ¡ndar cuando se realiza el paso de instalaciÃ³n.\nSi volvemos a ejecutar zig build --help observaremos como ahora la secciÃ³n Project-Specific Options muestra opciones para establecer la plataforma, caracterÃ­sticas de la cpu y la optimizaciÃ³n desde lÃ­nea de comandos.\n1 2 3 4 5 6 7 8 9 Project-Specific Options: -Dtarget=[string] The CPU architecture, OS, and ABI to build for -Dcpu=[string] Target CPU features to add or subtract -Doptimize=[enum] Prioritize performance, safety, or binary size (-O flag) Supported Values: Debug ReleaseSafe ReleaseFast ReleaseSmall Al lanzar zig build se generarÃ¡n dos directorios importantes:\nzig-cache: Este directorio contiene artefactos de construcciÃ³n intermedios, como archivos de objeto, y es utilizado por el sistema de construcciÃ³n de Zig para almacenar en cachÃ© los resultados de la construcciÃ³n y acelerar las compilaciones posteriores. zig-out: Este directorio almacena la salida final de tu proceso de construcciÃ³n, incluyendo ejecutables, bibliotecas y otros binarios. CompilaciÃ³n cruzada hecha fÃ¡cil ğŸŒ‰ Una de las caracterÃ­sticas mÃ¡s poderosas del sistema de construcciÃ³n de Zig es su capacidad para compilar de forma cruzada tus proyectos. Para ello simplemente proporciona la opciÃ³n --target cuando ejecutes zig build:\n1 zig build -Dtarget=aarch64-linux-gnu Este comando compila tu proyecto para la plataforma objetivo especificada, manejando todas las complejidades por ti. ğŸ‰\n1 2 $ file zig-out/bin/executable zig-out/bin/executable: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, with debug_info, not stripped AÃ±adiendo mÃ¡s pasos ğŸ‘£ğŸ‘£ Ahora que sabemos como funciona podemos aÃ±adir otros dos pasos, uno para ejecutar el programa y otro para lanzar los tests:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 const std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.Build) void { // compilaciÃ³n const target = b.standardTargetOptions(.{}); const optimize = b.standardOptimizeOption(.{}); const exe = b.addExecutable(.{ .name = \u0026#34;executable\u0026#34;, .root_source_file = .{ .path = \u0026#34;main.zig\u0026#34; }, .target = target, .optimize = optimize, }); b.installArtifact(exe); // ejecuciÃ³n const run_cmd = b.addRunArtifact(exe); if (b.args) |args| { run_cmd.addArgs(args); } run_cmd.step.dependOn(b.getInstallStep()); const run_step = b.step(\u0026#34;run\u0026#34;, \u0026#34;Run the app\u0026#34;); run_step.dependOn(\u0026amp;run_cmd.step); // tests const unit_tests = b.addTest(.{ .root_source_file = .{ .path = \u0026#34;main_test.zig\u0026#34; }, .target = target, .optimize = optimize, }); const run_unit_tests = b.addRunArtifact(unit_tests); const test_step = b.step(\u0026#34;test\u0026#34;, \u0026#34;Run unit tests\u0026#34;); test_step.dependOn(\u0026amp;run_unit_tests.step); } En este cÃ³digo podemos ver\nEl bloque if (b.args) |args| {...}: AÃ±ade cualquier argumento pasado al comando de ejecuciÃ³n.\nconst run_step = b.step(\u0026quot;run\u0026quot;, \u0026quot;Run the app\u0026quot;): Crea un paso de construcciÃ³n que ejecuta el comando de ejecuciÃ³n.\nconst unit_tests = b.addTest(.) y const run_unit_tests = b.addRunArtifact(unit_tests): Crea un paso para las pruebas unitarias. Este paso construye el ejecutable de prueba pero no lo ejecuta.\nconst test_step = b.step(\u0026quot;test\u0026quot;, \u0026quot;Run unit tests\u0026quot;): Este paso ejecuta las pruebas unitarias.\nPara aÃ±adir los test aÃ±adimos el archivo main_test.zig:\n1 2 3 4 5 6 7 8 9 10 const std = @import(\u0026#34;std\u0026#34;); test \u0026#34;simple test\u0026#34; { try std.testing.expect(addOne(41) == 42); } fn addOne(number: i32) i32 { return number + 1; } Para crear un caso de prueba en Zig, usa la palabra clave test, seguida de un nombre de prueba y un bloque de cÃ³digo.\nPara lanzar los test usamos el comando zig build test. Si todo va bien no deberÃ­amos ver ningÃºn error, el comando es realmente muy silencioso.\nÂ¿Se puede mÃ¡s fÃ¡cil? ğŸ˜… Crear un archivo build.zig puede ser un poco tedioso, mÃ¡s aun cuando todavÃ­a no dominamos el lenguaje. Pero no tienes por quÃ© empezar desde cero. El comando zig init-exe te generarÃ¡ las carpetas y archivos necesarios para compilar, ejecutar y pasar los test de un proyecto de bÃ¡sico de ejemplo en el directorio donde te encuentres.\nÂ¿QuÃ© sigue? ğŸŒŸ Â¡Eso es todo! Ahora tienes un sÃ³lido entendimiento del sistema de construcciÃ³n de Zig y puedes usarlo para gestionar, construir y compilar de forma cruzada tus proyectos con facilidad. ğŸ’¡\nÂ¡Feliz codificaciÃ³n y nos vemos en la prÃ³xima publicaciÃ³n! ğŸ‘©â€ğŸ’»ğŸ‘¨â€ğŸ’»ğŸš€\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/una-gu%C3%ADa-del-sistema-de-construcci%C3%B3n-en-zig/","summary":"Â¡Hola, entusiastas de Zig! ğŸ‘‹ En nuestra publicaciÃ³n anterior, dimos nuestros primeros pasos en el mundo de Zig. Hoy, vamos a adentrarnos en el corazÃ³n de la gestiÃ³n de proyectos de Zig: el sistema de construcciÃ³n de Zig. Â¡Empecemos! ğŸ‰\nÂ¿QuÃ© es el sistema de construcciÃ³n de Zig? ğŸ¤” El sistema de construcciÃ³n de Zig es una herramienta poderosa e incorporada que te ayuda a gestionar, compilar, probar y enlazar tus proyectos.","title":"Una guÃ­a del sistema de construcciÃ³n de Zig ğŸ—ï¸"},{"content":"Â¡Hola, entusiastas de Zig! Hoy vamos a explorar un emocionante campo donde Zig realmente brilla: WebAssembly (Wasm). PrepÃ¡rate para desbloquear el poder de Zig en el navegador! ğŸŒğŸ’ª\nÂ¿QuÃ© es WebAssembly? ğŸ§ WebAssembly es un formato de instrucciÃ³n binaria diseÃ±ado como un objetivo portable para la compilaciÃ³n de lenguajes de alto nivel como C, C++, Rust, y por supuesto, Zig. Nos permite ejecutar cÃ³digo en la web a una velocidad cercana a la nativa, abriendo la web a un nuevo rango de aplicaciones.\nÂ¿Por quÃ© Zig con WebAssembly? ğŸ¤” La simplicidad, eficiencia y robustez de Zig lo convierten en una excelente elecciÃ³n para el desarrollo de WebAssembly. La capacidad de Zig para compilar cruzadamente sin problemas es una enorme ventaja, y su fuerte enfoque en la seguridad es perfecto para el entorno protegido de la web.\nEmpezando con Zig y WebAssembly ğŸš€ Vamos a crear un simple programa Zig y compilarlo a WebAssembly.\nComienza escribiendo un simple programa Zig. Abre tu editor de cÃ³digo y crea un nuevo archivo llamado hello.zig: âš ï¸ Â¡AtenciÃ³n, programador! Este post utiliza la versiÃ³n dev 0.11.0 de Zig\n1 2 3 4 5 6 7 extern fn print(a: i32) void; export fn add(a: i32, b: i32) i32 { print(1234); return a + b; } Este cÃ³digo establece una interfaz entre Zig y JavaScript. La declaraciÃ³n extern fn print(a: i32) void; permite a Zig usar la funciÃ³n print de JavaScript, y export fn add(a: i32, b: i32) i32 { ... } proporciona una funciÃ³n que puede ser llamada desde JavaScript.\nPara compilar este cÃ³digo Zig a WebAssembly, aÃ±ade un archivo build.zig 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.build.Builder) void { const target = std.zig.CrossTarget{ .cpu_arch = .wasm32, .os_tag = .freestanding, .abi = .musl, }; const optimize = b.standardOptimizeOption(.{ .preferred_optimize_mode = .ReleaseFast }); const lib = b.addSharedLibrary(.{ .name = \u0026#34;hello\u0026#34;, .root_source_file = .{ .path = \u0026#34;./hello.zig\u0026#34; }, .target = target, .optimize = optimize, }); lib.rdynamic = true; b.installArtifact(lib); } Vamos a verlo con detalle:\nconst std = @import(\u0026quot;std\u0026quot;);\nAquÃ­ estamos importando la biblioteca estÃ¡ndar de Zig (std). Esto nos da acceso a todas las funciones y utilidades proporcionadas por la biblioteca estÃ¡ndar. ğŸ“šğŸ”\npub fn build(b: *std.build.Builder) void {\nEn esta lÃ­nea, definimos la funciÃ³n principal build para nuestro script de compilaciÃ³n, que recibe un puntero a una instancia de std.build.Builder. Este es nuestro guÃ­a para la aventura de la construcciÃ³n de cÃ³digo. ğŸ—ï¸ğŸ—ºï¸\nconst target = std.zig.CrossTarget{...};\nAquÃ­ estamos creando un objetivo de compilaciÃ³n cruzada para WebAssembly con el tag del sistema operativo freestanding y la interfaz binaria de aplicaciÃ³n musl. Esta es la maleta que preparamos para nuestro viaje a WebAssembly Land. ğŸ›„ğŸ¯\nconst optimize = b.standardOptimizeOption(...);\nAquÃ­ definimos las opciones de optimizaciÃ³n. Estamos eligiendo la opciÃ³n de optimizaciÃ³n ReleaseFast, que es como decir \u0026ldquo;Â¡Vamos a correr como el viento, pero sin tropezar!\u0026rdquo; ğŸƒâ€â™‚ï¸ğŸ’¨\nconst lib = b.addSharedLibrary(...);\nEn este paso, le decimos a nuestro guÃ­a (el constructor b) que queremos construir una biblioteca compartida llamada hello a partir del archivo de origen hello.zig, con las opciones de objetivo y optimizaciÃ³n que definimos anteriormente. Es como pedirle a nuestro guÃ­a que prepare los planes para construir un puente a WebAssembly Land. ğŸŒ‰ğŸ› ï¸\nlib.rdynamic = true;\nLa opciÃ³n rdynamic es absolutamente necesaria en Zig 0.11.0, ya que el linker de wasm integrado en Zig no exporta los sÃ­mbolos definidos. La opciÃ³n rdynamic sirve para enlazar dinamicamente librerÃ­as y es particularmente Ãºtil cuando quieres exportar sÃ­mbolos desde un ejecutable. El uso de esta opciÃ³n en el contexto de WebAssembly es una soluciÃ³n (workaround) a este problema.\nb.installArtifact(lib);\nFinalmente, le decimos a nuestro guÃ­a que instale la biblioteca que acabamos de construir. Esto coloca nuestra hermosa biblioteca hello en el lugar correcto para que otros puedan usarla. Es como colocar nuestro puente reciÃ©n construido en el mapa para que todos puedan encontrarlo. ğŸ—ºï¸ğŸŒ‰\nPara construir el proyecto teclea el siguiente comando:\n1 zig build Tenemos nuestro mÃ³dulo listo, ahora vamos por el HTML y Javascript. Creamos un archivo index.html: 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;es\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Zig: Â¡Hola WASM!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;Zig: Â¡Hola WASM!\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;(Â¡Abre la consola!)\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script src=\u0026#34;loader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; Creamos un script de carga para cargar y ejecutar nuestro mÃ³dulo WebAssembly. Creamos un nuevo archivo en el mismo directorio llamado loader.js: 1 2 3 4 5 6 7 8 9 WebAssembly.instantiateStreaming(fetch(\u0026#39;zig-out/lib/hello.wasm\u0026#39;), { env: { print: function (x) { console.log(\u0026#34;Llamada desde zig:\u0026#34;, x); } } }).then(result =\u0026gt; { const add = result.instance.exports.add; console.log(\u0026#34;Llamada a Zig:\u0026#34;, add(3, 5)); }); Este cÃ³digo muestra cÃ³mo se puede cargar y ejecutar un mÃ³dulo WebAssembly en un entorno de navegador. Para ello, se prepara una solicitud HTTP GET al archivo .wasm que se pasa a WebAssembly.instantiateStreaming para descargar, compilar y ejecutar el mÃ³dulo.\nEl objeto de importaciÃ³n que se pasa a WebAssembly.instantiateStreaming representa el entorno del host. En este caso, proporcionamos una funciÃ³n de impresiÃ³n que se puede llamar desde el mÃ³dulo WebAssembly. Una vez que el mÃ³dulo se ha instanciado correctamente, podemos acceder a las funciones exportadas y llamarlas como cualquier otra funciÃ³n de JavaScript.\nInicia cualquier servidor HTTP Debido a las polÃ­ticas de CORS en la mayorÃ­a de los navegadores, es necesario servir nuestro mÃ³dulo WebAssembly a travÃ©s de un servidor HTTP. Puedes hacerlo fÃ¡cilmente con Python ejecutando el comando:\n1 $ python -m SimpleHTTPServer 8001 Navega a http://localhost:8001 en tu navegador, y estarÃ¡s listo para ver el funcionamiento de tu programa.\nÂ¡Y eso es todo! Acabas de escribir tu primer programa Zig para WebAssembly. ğŸ‰\nQuiero mÃ¡s ğŸŒŸ Atentos a nuestros prÃ³ximos posts, donde iremos un paso mÃ¡s allÃ¡ y construiremos juntos y poco a poco un clÃ¡sico: Â¡El juego ese de bloques que caen de arriba! No solo serÃ¡ una oportunidad para divertirnos mientras programamos, sino tambiÃ©n una forma efectiva de aprender y profundizar en nuestros conocimientos sobre WebAssembly, Zig, juegos, IA, usabilidad y muchos otros.\nÂ¡PruÃ©balo un poco para ir abriendo el apetito!\nEspero que esta publicaciÃ³n te haya proporcionado una sÃ³lida introducciÃ³n a WebAssembly y Zig. Â¡Nos vemos en la prÃ³xima!\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/webassembly-y-zig-comenzando/","summary":"Â¡Hola, entusiastas de Zig! Hoy vamos a explorar un emocionante campo donde Zig realmente brilla: WebAssembly (Wasm). PrepÃ¡rate para desbloquear el poder de Zig en el navegador! ğŸŒğŸ’ª\nÂ¿QuÃ© es WebAssembly? ğŸ§ WebAssembly es un formato de instrucciÃ³n binaria diseÃ±ado como un objetivo portable para la compilaciÃ³n de lenguajes de alto nivel como C, C++, Rust, y por supuesto, Zig. Nos permite ejecutar cÃ³digo en la web a una velocidad cercana a la nativa, abriendo la web a un nuevo rango de aplicaciones.","title":"WebAssembly y Zig: Comenzando ğŸ•¸ï¸ğŸš€"}]