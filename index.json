[{"content":"Â¡Hola a todos! ğŸ™Œ Â¡Vamos a sumergirnos en uno de los conceptos mÃ¡s apasionantes y poderosos de Zig: el comptime! Esta caracterÃ­stica, si no has oÃ­do hablar de ella, puede cambiar completamente tu perspectiva sobre cÃ³mo escribir cÃ³digo. ğŸ˜®\nÂ¿QuÃ© es comptime? El tÃ©rmino comptime viene de \u0026ldquo;Compile Time\u0026rdquo; que, traducido al espaÃ±ol, serÃ­a \u0026ldquo;Tiempo de CompilaciÃ³n\u0026rdquo;. En realidad has usado esa funcionalidad muchas veces, en su forma mÃ¡s bÃ¡sica, cada vez que utilizas una constante. En Zig, puedes decidir quÃ© parte de tu cÃ³digo se ejecutarÃ¡ en tiempo de compilaciÃ³n y cuÃ¡l en tiempo de ejecuciÃ³n. ğŸ•“\nPrincipales ventajas de comptime QuizÃ¡s te estÃ©s preguntando, Â¿por quÃ© querrÃ­amos hacer cÃ¡lculos en tiempo de compilaciÃ³n?\nFlexibilidad: Gracias a comptime, puedes generar cÃ³digo en tiempo de compilaciÃ³n de forma dinÃ¡mica. Esto significa que puedes decidir cÃ³mo se comportarÃ¡ tu programa en funciÃ³n de las condiciones existentes durante la compilaciÃ³n. ğŸ˜\nEficiencia: Al mover ciertas operaciones al tiempo de compilaciÃ³n, puedes mejorar significativamente la eficiencia de tu cÃ³digo en tiempo de ejecuciÃ³n. En lugar de calcular algo cada vez que se ejecuta tu programa, lo calculas una vez durante la compilaciÃ³n y ya estÃ¡. Es como preparar toda la comida de antemano para que, cuando lleguen los invitados, Â¡solo tengas que encender el fuego! ğŸ³â²ï¸\nSeguridad: comptime puede ayudarte a detectar errores en tiempo de compilaciÃ³n en lugar de en tiempo de ejecuciÃ³n. Cuanto antes detectes los errores, mÃ¡s segura serÃ¡ tu aplicaciÃ³n. ğŸ’ª\nAbstracciÃ³n sin costo: A diferencia de otros lenguajes que pagan un precio por abstracciones de alto nivel (con rendimiento mÃ¡s lento o mÃ¡s memoria usada), Zig permite abstracciones sin costos adicionales, gracias al poder de comptime.ğŸ‰\nEjemplo bÃ¡sico de uso de comptime En su forma mÃ¡s bÃ¡sica comptime es la forma en la que una variable se calcula en tiempo de compilaciÃ³n para convertirse en una constante en tiempo de ejecuciÃ³n. AquÃ­ hay un pequeÃ±o fragmento de cÃ³digo para que te hagas una idea de cÃ³mo se utiliza comptime.\nâš ï¸ Â¡AtenciÃ³n, programador! Este post utiliza la versiÃ³n dev 0.11.0 de Zig\nfn suma() u64 { var r: u64 = 0; for (1..100) |i| { r += i; } return r; } pub fn main() void { var s = comptime suma(); std.debug.print(\u0026#34;{}\u0026#34;, .{s}); sumaB(); } Cuando compiles este cÃ³digo, verÃ¡s que suma se calcula en tiempo de compilaciÃ³n y su resultado es simplemente una constante. En tiempo de ejecuciÃ³n, este bloque comptime no tiene ningÃºn efecto.\nexample.main: push rbp mov rbp, rsp sub rsp, 16 mov qword ptr [rbp - 8], 4950 call debug.print__anon_3471 add rsp, 16 pop rbp ret ExplicaciÃ³n del cÃ³digo Este cÃ³digo es esamblador de arquitectura x86-64 (o AMD64):\npush rbp: Guarda el valor actual del puntero base del marco (frame base pointer) en la pila. Esto se hace generalmente al inicio de una funciÃ³n para preservar el valor actual de rbp para poder restaurarlo mÃ¡s tarde.\nmov rbp, rsp: Establece el puntero base del marco al valor actual del puntero de la pila (stack pointer). Esto se hace para que la funciÃ³n tenga un punto de referencia fijo para acceder a las variables locales y los argumentos.\nsub rsp, 16: Reserva 16 bytes en la pila para las variables locales de esta funciÃ³n, moviendo el puntero de la pila hacia abajo (en la mayorÃ­a de las arquitecturas, la pila crece hacia abajo en la memoria).\nmov qword ptr [rbp - 8], 4950: Guarda el valor 4950 en la ubicaciÃ³n de la pila 8 bytes por debajo del puntero base del marco. Probablemente esto estÃ¡ inicializando una variable local.\ncall debug.print__anon_3471: Llama a la funciÃ³n debug.print__anon_3471. Esta funciÃ³n pinta el valor de la variable local que acabamos de inicializar.\nadd rsp, 16: Restablece el puntero de la pila a su posiciÃ³n antes de que reservÃ¡ramos espacio para las variables locales. Esto efectivamente \u0026ldquo;libera\u0026rdquo; ese espacio de la pila.\npop rbp: Restaura el puntero base del marco a su valor antes de la llamada a la funciÃ³n, esencialmente limpiando despuÃ©s de que la funciÃ³n haya terminado.\nret: Retorna de la funciÃ³n, saltando de vuelta a la direcciÃ³n de retorno almacenada en la pila por la instrucciÃ³n call que llamÃ³ a esta funciÃ³n.\nOtra forma de asignar un cÃ¡culo en comptime a una variable o constate es usando break :equita valor en un bloque:\nvar s = comptime e: { var r: u64 = 0; for (1..100) |i| { r += i; } break :e r; }; Â¿Pero que pasarÃ­a si nos encontramos un bucle demasiado largo en tiempo de compilaciÃ³n? Comptime tiene un limitador de la cantidad de ramificaciones que se pueden evaluar en tiempo de compilaciÃ³n, lo cual es Ãºtil para prevenir bucles infinitos y otros problemas que pueden consumir una cantidad excesiva de recursos durante la compilaciÃ³n. Se puede cambiar el lÃ­mite con la funciÃ³n @setEvalBranchQuota(), que por defecto es 1000.\nCombiene recordarlo si nos encontramos con un error similar a este compilando:\nerror: evaluation exceeded 1000 backwards branches note: use @setEvalBranchQuota() to raise the branch limit from 1000 ComparaciÃ³n con tiempo de ejecuciÃ³n Entonces, Â¿cÃ³mo se compara comptime con los cÃ¡lculos en tiempo de ejecuciÃ³n tradicionales? Cuando un programa Zig se estÃ¡ ejecutando, a menudo hay decisiones que tomar, como elegir quÃ© ramas de cÃ³digo ejecutar. Normalmente, esto ocurre en tiempo de ejecuciÃ³n, pero con comptime, estas decisiones se pueden tomar en tiempo de compilaciÃ³n. Es como resolver la mayor parte del rompecabezas antes de que empiece a correr el reloj. â³ğŸ§©\nAplicaciones prÃ¡cticas de comptime De acuerdo, la teorÃ­a es buena, Â¡pero veamos comptime en acciÃ³n! Te guiarÃ© a travÃ©s de algunos ejemplos prÃ¡cticos donde comptime puede brillar, como cuando trabajas con metaprogramaciÃ³n o programaciÃ³n genÃ©rica. Â¡AquÃ­ es donde comptime pasa de ser simplemente \u0026lsquo;genial\u0026rsquo; a \u0026lsquo;absolutamente fantÃ¡stico\u0026rsquo;! ğŸŒŸğŸ”§\nQuÃ© es @compileLog En Zig, @compileLog es una funciÃ³n incorporada que te permite registrar mensajes durante el tiempo de compilaciÃ³n. Es una herramienta maravillosa para la depuraciÃ³n o para entender lo que estÃ¡ sucediendo en tiempo de compilaciÃ³n. AquÃ­ tienes un ejemplo rÃ¡pido:\ncomptime { const a = 5; @compileLog(\u0026#34;Valor de a en tiempo de compilaciÃ³n: \u0026#34;, a); } En el cÃ³digo anterior, @compileLog imprimirÃ¡ el mensaje \u0026ldquo;Valor de a en tiempo de compilaciÃ³n: 5\u0026rdquo; durante el proceso de compilaciÃ³n. Â¡Esto puede ser muy Ãºtil cuando estÃ¡s lidiando con expresiones o funciones comptime complejas! ğŸ¤”ğŸ’­\nHay que hace notar que, a dÃ­a de hoy, la compilaciÃ³n fallarÃ¡ si se ha ejecutado cualquier @compileLog. La razÃ³n es evitar que las librerÃ­as polucionen de mensajes la compilaciÃ³n de un programa.\nQuÃ© es @compileError @compileError es otra funciÃ³n incorporada en Zig que se utiliza para lanzar un error en tiempo de compilaciÃ³n. Esto es sÃºper Ãºtil para asegurar ciertas condiciones durante el tiempo de compilaciÃ³n y detener la compilaciÃ³n si no se cumplen. AsÃ­ es cÃ³mo puedes usarlo:\ncomptime { if (!std.builtin.target.isWasm()) { @compileError(\u0026#34;WasmPageAllocator is only available for wasm32 arch\u0026#34;); } } En este ejemplo, si la arquitectura en la se estÃ¡ intentando compilar el programa no es la adecuada se lanzarÃ¡ un error de compilaciÃ³n con @compileError ğŸ’¥ğŸ›‘\nComptime para metaprogramaciÃ³n La metaprogramaciÃ³n se refiere a la capacidad de un programa para tratar su cÃ³digo como datos y manipularlo. En Zig, comptime proporciona una forma poderosa de lograr la metaprogramaciÃ³n. Por ejemplo, puedes generar funciones especializadas para diferentes tipos:\nfn createAdder(comptime T: type) type { return struct { fn add(a: T, b: T) T { return a + b; } }; } const IntAdder = createAdder(i32); const FloatAdder = createAdder(f32); var i = IntAdder.add(10, 20); var f = FloatAdder.add(1.0, 2.0); En el cÃ³digo anterior, estamos generando dos estructuras en tiempo de compilaciÃ³n: IntAdder y FloatAdder. Cada una tiene una funciÃ³n add, pero trabajan con tipos diferentes (i32 y f32). Â¡Esto es solo la punta del iceberg cuando se trata de metaprogramaciÃ³n con comptime! ğŸ§ ğŸ”®\nPor ejemplo, podemos crear estructuras completas en tiempo de compilaciÃ³n:\nfn makeType(comptime n: usize) type { var fields: [n]std.builtin.Type.StructField = undefined; inline for (0..n) |v| { const default_value: u32 = v; fields[v] = .{ .name = std.fmt.comptimePrint(\u0026#34;field{}\u0026#34;, .{v}), .type = @TypeOf(default_value), .default_value = @ptrCast(*const anyopaque, \u0026amp;default_value), .is_comptime = false, .alignment = @alignOf(@TypeOf(default_value)), }; } return @Type(.{ .Struct = .{ .layout = .Auto, .fields = fields[0..], .decls = \u0026amp;.{}, .is_tuple = false, } }); } const T2 = comptime makeType(2); std.debug.print(\u0026#34;{any}\\n\u0026#34;, .{T2{}}); const T3 = comptime makeType(3); std.debug.print(\u0026#34;{any}\\n\u0026#34;, .{T3{}}); sample.makeType(2){ .field0 = 0, .field1 = 1 } sample.makeType(3){ .field0 = 0, .field1 = 1, .field2 = 2 } Detalles importantes en este cÃ³digo:\nLa matriz fields tiene un tamaÃ±o fijo determinado en tiempo de compilaciÃ³n.\nEl bucle inline for itera sobre el rango 0..n. Es por tanto un bucle que se desenrrolla. Â¿Crees que es obligatorio este desenrollado? Â¿En necesario?\nComptime y asignaciÃ³n de memoria Lo ideal serÃ­a poder utilizar todas las estructuras de datos disponibles en Zig para poder ejectuar cÃ¡lculos en tiempo de compilaciÃ³n. Aunque de momento no existe en la librerÃ­a estÃ¡ndar un asignador de memoria (allocator) de Zig en para tiempo de compilaciÃ³n, podemos implementar el nuestro propio con facilidad. AsÃ­, con un poco de cuaidado, podremos usar en comptime, de forma auxilia,r estructuras como std.ArrayList:\nfn makeSlice(allocator: std.mem.Allocator) ![]u8 { var list = std.ArrayList(u8).init(allocator); defer list.deinit(); try list.append(1); try list.append(2); return try list.toOwnedSlice(); } const array = comptime e: { var buffer: [1024]u8 = undefined; var cfba = ComptimeFixedBufferAllocator.init(\u0026amp;buffer); const v = makeSlice(cfba.allocator()) catch { @compileError(\u0026#34;allocation error, increase fixed buffer size\u0026#34;); }; break :e v[0..].*; }; std.debug.print(\u0026#34;{any}\\n\u0026#34;, .{array}); âš ï¸ Â¡AtenciÃ³n, programador! Ten en cuenta que siempre debes transformar los slices en matrices constantes para evitar incrustar todo el buffer de memoria del allocator en el programa compilado final, fÃ­jate en break :e v[0..].*;. Esto es importante.\nVer cÃ³digo de ejemplo de un allocator para comptime Es bÃ¡sicamente una copia de std.heap.FixedBufferAllocator. Por cierto, Â¿por quÃ© crees que no podemos usarlo en comptime?:\npub const ComptimeFixedBufferAllocator = struct { end_index: usize, buffer: []u8, pub fn init(buffer: []u8) ComptimeFixedBufferAllocator { return ComptimeFixedBufferAllocator{ .buffer = buffer, .end_index = 0, }; } pub fn allocator(self: *ComptimeFixedBufferAllocator) std.mem.Allocator { return .{ .ptr = self, .vtable = \u0026amp;.{ .alloc = alloc, .resize = resize, .free = free, }, }; } pub fn isLastAllocation(self: *ComptimeFixedBufferAllocator, buf: []u8) bool { return buf.ptr + buf.len == self.buffer.ptr + self.end_index; } fn alloc(ctx: *anyopaque, n: usize, log2_ptr_align: u8, ra: usize) ?[*]u8 { const self = @ptrCast(*ComptimeFixedBufferAllocator, @alignCast(@alignOf(ComptimeFixedBufferAllocator), ctx)); _ = ra; const ptr_align = @as(usize, 1) \u0026lt;\u0026lt; @intCast(std.mem.Allocator.Log2Align, log2_ptr_align); const adjust_off = std.mem.alignPointerOffset(self.buffer.ptr + self.end_index, ptr_align) orelse return null; const adjusted_index = self.end_index + adjust_off; const new_end_index = adjusted_index + n; if (new_end_index \u0026gt; self.buffer.len) return null; self.end_index = new_end_index; return self.buffer.ptr + adjusted_index; } fn resize( ctx: *anyopaque, buf: []u8, log2_buf_align: u8, new_size: usize, return_address: usize, ) bool { const self = @ptrCast(*ComptimeFixedBufferAllocator, @alignCast(@alignOf(ComptimeFixedBufferAllocator), ctx)); _ = log2_buf_align; _ = return_address; if (!self.isLastAllocation(buf)) { if (new_size \u0026gt; buf.len) return false; return true; } if (new_size \u0026lt;= buf.len) { const sub = buf.len - new_size; self.end_index -= sub; return true; } const add = new_size - buf.len; if (add + self.end_index \u0026gt; self.buffer.len) return false; self.end_index += add; return true; } fn free( ctx: *anyopaque, buf: []u8, log2_buf_align: u8, return_address: usize, ) void { const self = @ptrCast(*ComptimeFixedBufferAllocator, @alignCast(@alignOf(ComptimeFixedBufferAllocator), ctx)); _ = log2_buf_align; _ = return_address; if (self.isLastAllocation(buf)) { self.end_index -= buf.len; } } pub fn reset(self: *ComptimeFixedBufferAllocator) void { self.end_index = 0; } }; Recuerda que aunque comptime nos permite realizar algunos trucos poderosos, no es una soluciÃ³n milagrosa. Es simplemente otra herramienta en nuestro kit de herramientas Zig que, cuando se usa adecuadamente, puede conducir a un cÃ³digo mÃ¡s limpio, eficiente y robusto. Â¡Pero como siempre, con un gran poder viene una gran responsabilidad! AsÃ­ que usemos comptime sabiamente\u0026hellip;\nLimitaciones de comptime ï¸ğŸ•¸ï¸ Hay algunos posibles problemas al usar comptime de los que debes estar al tanto ğŸ˜…. Los principales son:\nSin operaciones de I/O: Durante el tiempo de compilaciÃ³n, no puedes realizar ninguna operaciÃ³n de entrada/salida. AsÃ­ es, no puedes leer archivos, escribir en la consola, comunicarte a travÃ©s de la red, Â¡nada! Recuerda, comptime opera en una mÃ¡quina abstracta idealizada sin acceso al mundo exterior. ğŸŒğŸ”’\nSin acceso a variables de entorno: De manera similar, comptime no tiene acceso a las variables de entorno en tiempo de ejecuciÃ³n. Esto incluye cosas como la hora del sistema, el identificador del proceso o las variables de entorno especÃ­ficas del usuario. Â¡Todo se trata del cÃ³digo, amigos! ğŸ–¥ï¸ğŸš«\nAsignaciÃ³n de memoria: Hablamos antes de cÃ³mo comptime gestiona la memoria y la falta de un allocator para comptime. Es importante recordar que comptime y el tiempo de ejecuciÃ³n son dos dominios diferentes. ğŸ§™â€â™‚ï¸ğŸ°\nÂ¡Y ya estÃ¡, amigos!. Un profundo viaje al mundo mÃ¡gico de comptime en Zig. Espero que hayas disfrutado nuestro recorrido y que ahora estÃ©s tan entusiasmado con comptime como yo. Recuerda, el aprendizaje es un proceso continuo, asÃ­ que nunca dejes de explorar y experimentar con Zig. Â¡Sigue codificando con pasiÃ³n y creatividad! ğŸš€ğŸ’»\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/zig-comptime/","summary":"Â¡Hola a todos! ğŸ™Œ Â¡Vamos a sumergirnos en uno de los conceptos mÃ¡s apasionantes y poderosos de Zig: el comptime! Esta caracterÃ­stica, si no has oÃ­do hablar de ella, puede cambiar completamente tu perspectiva sobre cÃ³mo escribir cÃ³digo. ğŸ˜®\nÂ¿QuÃ© es comptime? El tÃ©rmino comptime viene de \u0026ldquo;Compile Time\u0026rdquo; que, traducido al espaÃ±ol, serÃ­a \u0026ldquo;Tiempo de CompilaciÃ³n\u0026rdquo;. En realidad has usado esa funcionalidad muchas veces, en su forma mÃ¡s bÃ¡sica, cada vez que utilizas una constante.","title":"Zig comptime"},{"content":"Â¡Hola, entusiastas de Zig! Hoy vamos a explorar un emocionante campo donde Zig realmente brilla: WebAssembly (Wasm). PrepÃ¡rate para desbloquear el poder de Zig en el navegador! ğŸŒğŸ’ª\nÂ¿QuÃ© es WebAssembly? ğŸ§ WebAssembly es un formato de instrucciÃ³n binaria diseÃ±ado como un objetivo portable para la compilaciÃ³n de lenguajes de alto nivel como C, C++, Rust, y por supuesto, Zig. Nos permite ejecutar cÃ³digo en la web a una velocidad cercana a la nativa, abriendo la web a un nuevo rango de aplicaciones.\nÂ¿Por quÃ© Zig con WebAssembly? ğŸ¤” La simplicidad, eficiencia y robustez de Zig lo convierten en una excelente elecciÃ³n para el desarrollo de WebAssembly. La capacidad de Zig para compilar cruzadamente sin problemas es una enorme ventaja, y su fuerte enfoque en la seguridad es perfecto para el entorno protegido de la web.\nEmpezando con Zig y WebAssembly ğŸš€ Vamos a crear un simple programa Zig y compilarlo a WebAssembly.\nComienza escribiendo un simple programa Zig. Abre tu editor de cÃ³digo y crea un nuevo archivo llamado hello.zig: âš ï¸ Â¡AtenciÃ³n, programador! Este post utiliza la versiÃ³n dev 0.11.0 de Zig\nextern fn print(a: i32) void; export fn add(a: i32, b: i32) i32 { print(1234); return a + b; } Este cÃ³digo establece una interfaz entre Zig y JavaScript. La declaraciÃ³n extern fn print(a: i32) void; permite a Zig usar la funciÃ³n print de JavaScript, y export fn add(a: i32, b: i32) i32 { ... } proporciona una funciÃ³n que puede ser llamada desde JavaScript.\nPara compilar este cÃ³digo Zig a WebAssembly, aÃ±ade un archivo build.zig const std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.build.Builder) void { const target = std.zig.CrossTarget{ .cpu_arch = .wasm32, .os_tag = .freestanding, .abi = .musl, }; const optimize = b.standardOptimizeOption(.{ .preferred_optimize_mode = .ReleaseFast }); const lib = b.addSharedLibrary(.{ .name = \u0026#34;hello\u0026#34;, .root_source_file = .{ .path = \u0026#34;./hello.zig\u0026#34; }, .target = target, .optimize = optimize, }); lib.rdynamic = true; b.installArtifact(lib); } Vamos a verlo con detalle:\nconst std = @import(\u0026quot;std\u0026quot;);\nAquÃ­ estamos importando la biblioteca estÃ¡ndar de Zig (std). Esto nos da acceso a todas las funciones y utilidades proporcionadas por la biblioteca estÃ¡ndar. ğŸ“šğŸ”\npub fn build(b: *std.build.Builder) void {\nEn esta lÃ­nea, definimos la funciÃ³n principal build para nuestro script de compilaciÃ³n, que recibe un puntero a una instancia de std.build.Builder. Este es nuestro guÃ­a para la aventura de la construcciÃ³n de cÃ³digo. ğŸ—ï¸ğŸ—ºï¸\nconst target = std.zig.CrossTarget{...};\nAquÃ­ estamos creando un objetivo de compilaciÃ³n cruzada para WebAssembly con el tag del sistema operativo freestanding y la interfaz binaria de aplicaciÃ³n musl. Esta es la maleta que preparamos para nuestro viaje a WebAssembly Land. ğŸ›„ğŸ¯\nconst optimize = b.standardOptimizeOption(...);\nAquÃ­ definimos las opciones de optimizaciÃ³n. Estamos eligiendo la opciÃ³n de optimizaciÃ³n ReleaseFast, que es como decir \u0026ldquo;Â¡Vamos a correr como el viento, pero sin tropezar!\u0026rdquo; ğŸƒâ€â™‚ï¸ğŸ’¨\nconst lib = b.addSharedLibrary(...);\nEn este paso, le decimos a nuestro guÃ­a (el constructor b) que queremos construir una biblioteca compartida llamada hello a partir del archivo de origen hello.zig, con las opciones de objetivo y optimizaciÃ³n que definimos anteriormente. Es como pedirle a nuestro guÃ­a que prepare los planes para construir un puente a WebAssembly Land. ğŸŒ‰ğŸ› ï¸\nlib.rdynamic = true;\nLa opciÃ³n rdynamic es absolutamente necesaria en Zig 0.11.0, ya que el linker de wasm integrado en Zig no exporta los sÃ­mbolos definidos. La opciÃ³n rdynamic sirve para enlazar dinamicamente librerÃ­as y es particularmente Ãºtil cuando quieres exportar sÃ­mbolos desde un ejecutable. El uso de esta opciÃ³n en el contexto de WebAssembly es una soluciÃ³n (workaround) a este problema.\nb.installArtifact(lib);\nFinalmente, le decimos a nuestro guÃ­a que instale la biblioteca que acabamos de construir. Esto coloca nuestra hermosa biblioteca hello en el lugar correcto para que otros puedan usarla. Es como colocar nuestro puente reciÃ©n construido en el mapa para que todos puedan encontrarlo. ğŸ—ºï¸ğŸŒ‰\nPara construir el proyecto teclea el siguiente comando:\nzig build Tenemos nuestro mÃ³dulo listo, ahora vamos por el HTML y Javascript. Creamos un archivo index.html: \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;es\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Zig: Â¡Hola WASM!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;Zig: Â¡Hola WASM!\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;(Â¡Abre la consola!)\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script src=\u0026#34;loader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; Creamos un script de carga para cargar y ejecutar nuestro mÃ³dulo WebAssembly. Creamos un nuevo archivo en el mismo directorio llamado loader.js: WebAssembly.instantiateStreaming(fetch(\u0026#39;zig-out/lib/hello.wasm\u0026#39;), { env: { print: function (x) { console.log(\u0026#34;Llamada desde zig:\u0026#34;, x); } } }).then(result =\u0026gt; { const add = result.instance.exports.add; console.log(\u0026#34;Llamada a Zig:\u0026#34;, add(3, 5)); }); Este cÃ³digo muestra cÃ³mo se puede cargar y ejecutar un mÃ³dulo WebAssembly en un entorno de navegador. Para ello, se prepara una solicitud HTTP GET al archivo .wasm que se pasa a WebAssembly.instantiateStreaming para descargar, compilar y ejecutar el mÃ³dulo.\nEl objeto de importaciÃ³n que se pasa a WebAssembly.instantiateStreaming representa el entorno del host. En este caso, proporcionamos una funciÃ³n de impresiÃ³n que se puede llamar desde el mÃ³dulo WebAssembly. Una vez que el mÃ³dulo se ha instanciado correctamente, podemos acceder a las funciones exportadas y llamarlas como cualquier otra funciÃ³n de JavaScript.\nInicia cualquier servidor HTTP Debido a las polÃ­ticas de CORS en la mayorÃ­a de los navegadores, es necesario servir nuestro mÃ³dulo WebAssembly a travÃ©s de un servidor HTTP. Puedes hacerlo fÃ¡cilmente con Python ejecutando el comando:\n$ python -m SimpleHTTPServer 8001 Navega a http://localhost:8001 en tu navegador, y estarÃ¡s listo para ver el funcionamiento de tu programa.\nÂ¡Y eso es todo! Acabas de escribir tu primer programa Zig para WebAssembly. ğŸ‰\nQuiero mÃ¡s ğŸŒŸ Atentos a nuestros prÃ³ximos posts, donde iremos un paso mÃ¡s allÃ¡ y construiremos juntos y poco a poco un clÃ¡sico: Â¡El juego ese de bloques que caen de arriba! No solo serÃ¡ una oportunidad para divertirnos mientras programamos, sino tambiÃ©n una forma efectiva de aprender y profundizar en nuestros conocimientos sobre WebAssembly, Zig, juegos, IA, algoritmos, estructuras de datos, usabilidad y muchos otros.\nÂ¡PruÃ©balo un poco para ir abriendo el apetito!\nEspero que esta publicaciÃ³n te haya proporcionado una sÃ³lida introducciÃ³n a WebAssembly y Zig. Â¡Nos vemos en la prÃ³xima!\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/webassembly-y-zig-comenzando/","summary":"Â¡Hola, entusiastas de Zig! Hoy vamos a explorar un emocionante campo donde Zig realmente brilla: WebAssembly (Wasm). PrepÃ¡rate para desbloquear el poder de Zig en el navegador! ğŸŒğŸ’ª\nÂ¿QuÃ© es WebAssembly? ğŸ§ WebAssembly es un formato de instrucciÃ³n binaria diseÃ±ado como un objetivo portable para la compilaciÃ³n de lenguajes de alto nivel como C, C++, Rust, y por supuesto, Zig. Nos permite ejecutar cÃ³digo en la web a una velocidad cercana a la nativa, abriendo la web a un nuevo rango de aplicaciones.","title":"WebAssembly y Zig: Comenzando ğŸ•¸ï¸ğŸš€"},{"content":"Â¡Hola, entusiastas de Zig! ğŸ‘‹ En nuestra publicaciÃ³n anterior, dimos nuestros primeros pasos en el mundo de Zig. Hoy, vamos a adentrarnos en el corazÃ³n de la gestiÃ³n de proyectos de Zig: el sistema de construcciÃ³n de Zig. Â¡Empecemos! ğŸ‰\nÂ¿QuÃ© es el sistema de construcciÃ³n de Zig? ğŸ¤” El sistema de construcciÃ³n de Zig es una herramienta poderosa e incorporada que te ayuda a gestionar, compilar, probar y enlazar tus proyectos. Simplifica procesos de construcciÃ³n complejos y proporciona una compilaciÃ³n cruzada sin interrupciones, permitiÃ©ndote apuntar a diferentes plataformas con facilidad.\nEmpezando con build.zig ğŸš€ Para aprovechar el sistema de construcciÃ³n de Zig, necesitas crear un archivo build.zig en el directorio raÃ­z de tu proyecto.\nEl conjunto de herramientas de Zig (toolchain) llama a la funciÃ³n build(b: *std.Build) void de build.zig. El parÃ¡metro bse utiliza para configurar y definir el proceso de construcciÃ³n mediante pasos o instrucciones que no formen ciclos o bucles.\nPor ejemplo, podemos crear nuestro propio paso my-step:\nâš ï¸ Â¡AtenciÃ³n, programador! Este post utiliza la versiÃ³n dev 0.11.0 de Zig\nconst std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.build.Builder) void { const my_step = b.step(\u0026#34;my-step\u0026#34;, \u0026#34;Este paso es mi paso\u0026#34;); _ = my_step; } Este paso aparecerÃ¡ en la ayuda si ejecutamos zig build --help, y aunque no hace nada, hace mucha ilusiÃ³n.\n$ zig build --help Usage: zig build [steps] [options] Steps: install (default) Copy build artifacts to prefix path uninstall Remove build artifacts from prefix path my-step Este paso es mi paso [...] Project-Specific Options: (none) [...] TambiÃ©n podemos observar en la ayuda una secciÃ³n Project-Specific Options, que por ahora aparece vacÃ­a.\nAÃ±adiendo el primer paso ğŸ‘£ Zig viene equipado con algunos pasos listos para usar. Uno de los mÃ¡s interesantes es addExecutable, que permite compilar un ejecutable o librerÃ­a.\nSi aÃ±adimos este main.zig al directorio:\nconst std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { const stdout = std.io.getStdOut().writer(); try stdout.print(\u0026#34;Hola otra vez\\n\u0026#34;, .{}); } Y definimos build.zig como:\nconst std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.Build) void { const target = b.standardTargetOptions(.{}); const optimize = b.standardOptimizeOption(.{}); const exe = b.addExecutable(.{ .name = \u0026#34;my-executable\u0026#34;, .root_source_file = .{ .path = \u0026#34;main.zig\u0026#34; }, .target = target, .optimize = optimize, }); b.installArtifact(exe); } Cuando ejecutemos el comando zig build se compilarÃ¡ nuestro ejecutable. Estas son las lÃ­neas principales:\nconst target = b.standardTargetOptions(.{}): Define las opciones de destino que estarÃ¡n disponibles y cual serÃ¡ la de defecto, lo que permite al usuario seleccionar para quÃ© plataforma se va a construir el cÃ³digo.\nconst optimize = b.standardOptimizeOption(.{}): Define las opciones de optimizaciÃ³n estÃ¡ndar, lo que permite al usuario seleccionar el nivel de optimizaciÃ³n para la compilaciÃ³n.\nconst exe = b.addExecutable(.): AÃ±ade un ejecutable al proceso de construcciÃ³n. Los parÃ¡metros definen cÃ³mo se construirÃ¡ el ejecutable, incluyendo el archivo fuente principal, las opciones de destino y las opciones de optimizaciÃ³n.\nb.installArtifact(exe): Esta lÃ­nea declara que el ejecutable creado en el paso anterior debe ser instalado en la ubicaciÃ³n estÃ¡ndar cuando se realiza el paso de instalaciÃ³n.\nSi volvemos a ejecutar zig build --help observaremos como ahora la secciÃ³n Project-Specific Options muestra opciones para establecer la plataforma, caracterÃ­sticas de la cpu y la optimizaciÃ³n desde lÃ­nea de comandos.\nProject-Specific Options: -Dtarget=[string] The CPU architecture, OS, and ABI to build for -Dcpu=[string] Target CPU features to add or subtract -Doptimize=[enum] Prioritize performance, safety, or binary size (-O flag) Supported Values: Debug ReleaseSafe ReleaseFast ReleaseSmall Al lanzar zig build se generarÃ¡n dos directorios importantes:\nzig-cache: Este directorio contiene artefactos de construcciÃ³n intermedios, como archivos de objeto, y es utilizado por el sistema de construcciÃ³n de Zig para almacenar en cachÃ© los resultados de la construcciÃ³n y acelerar las compilaciones posteriores. zig-out: Este directorio almacena la salida final de tu proceso de construcciÃ³n, incluyendo ejecutables, bibliotecas y otros binarios. CompilaciÃ³n cruzada hecha fÃ¡cil ğŸŒ‰ Una de las caracterÃ­sticas mÃ¡s poderosas del sistema de construcciÃ³n de Zig es su capacidad para compilar de forma cruzada tus proyectos. Para ello simplemente proporciona la opciÃ³n --target cuando ejecutes zig build:\nzig build -Dtarget=aarch64-linux-gnu Este comando compila tu proyecto para la plataforma objetivo especificada, manejando todas las complejidades por ti. ğŸ‰\n$ file zig-out/bin/executable zig-out/bin/executable: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, with debug_info, not stripped AÃ±adiendo mÃ¡s pasos ğŸ‘£ğŸ‘£ Ahora que sabemos como funciona podemos aÃ±adir otros dos pasos, uno para ejecutar el programa y otro para lanzar los tests:\nconst std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.Build) void { // compilaciÃ³n const target = b.standardTargetOptions(.{}); const optimize = b.standardOptimizeOption(.{}); const exe = b.addExecutable(.{ .name = \u0026#34;executable\u0026#34;, .root_source_file = .{ .path = \u0026#34;main.zig\u0026#34; }, .target = target, .optimize = optimize, }); b.installArtifact(exe); // ejecuciÃ³n const run_cmd = b.addRunArtifact(exe); if (b.args) |args| { run_cmd.addArgs(args); } run_cmd.step.dependOn(b.getInstallStep()); const run_step = b.step(\u0026#34;run\u0026#34;, \u0026#34;Run the app\u0026#34;); run_step.dependOn(\u0026amp;run_cmd.step); // tests const unit_tests = b.addTest(.{ .root_source_file = .{ .path = \u0026#34;main_test.zig\u0026#34; }, .target = target, .optimize = optimize, }); const run_unit_tests = b.addRunArtifact(unit_tests); const test_step = b.step(\u0026#34;test\u0026#34;, \u0026#34;Run unit tests\u0026#34;); test_step.dependOn(\u0026amp;run_unit_tests.step); } En este cÃ³digo podemos ver\nEl bloque if (b.args) |args| {...}: AÃ±ade cualquier argumento pasado al comando de ejecuciÃ³n.\nconst run_step = b.step(\u0026quot;run\u0026quot;, \u0026quot;Run the app\u0026quot;): Crea un paso de construcciÃ³n que ejecuta el comando de ejecuciÃ³n.\nconst unit_tests = b.addTest(.) y const run_unit_tests = b.addRunArtifact(unit_tests): Crea un paso para las pruebas unitarias. Este paso construye el ejecutable de prueba pero no lo ejecuta.\nconst test_step = b.step(\u0026quot;test\u0026quot;, \u0026quot;Run unit tests\u0026quot;): Este paso ejecuta las pruebas unitarias.\nPara aÃ±adir los test aÃ±adimos el archivo main_test.zig:\nconst std = @import(\u0026#34;std\u0026#34;); test \u0026#34;simple test\u0026#34; { try std.testing.expect(addOne(41) == 42); } fn addOne(number: i32) i32 { return number + 1; } Para crear un caso de prueba en Zig, usa la palabra clave test, seguida de un nombre de prueba y un bloque de cÃ³digo.\nPara lanzar los test usamos el comando zig build test. Si todo va bien no deberÃ­amos ver ningÃºn error, el comando es realmente muy silencioso.\nÂ¿Se puede mÃ¡s fÃ¡cil? ğŸ˜… Crear un archivo build.zig puede ser un poco tedioso, mÃ¡s aun cuando todavÃ­a no dominamos el lenguaje. Pero no tienes por quÃ© empezar desde cero. El comando zig init-exe te generarÃ¡ las carpetas y archivos necesarios para compilar, ejecutar y pasar los test de un proyecto de bÃ¡sico de ejemplo en el directorio donde te encuentres.\nÂ¿QuÃ© sigue? ğŸŒŸ Â¡Eso es todo! Ahora tienes un sÃ³lido entendimiento del sistema de construcciÃ³n de Zig y puedes usarlo para gestionar, construir y compilar de forma cruzada tus proyectos con facilidad. ğŸ’¡\nÂ¡Feliz codificaciÃ³n y nos vemos en la prÃ³xima publicaciÃ³n! ğŸ‘©â€ğŸ’»ğŸ‘¨â€ğŸ’»ğŸš€\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/una-gu%C3%ADa-del-sistema-de-construcci%C3%B3n-en-zig/","summary":"Â¡Hola, entusiastas de Zig! ğŸ‘‹ En nuestra publicaciÃ³n anterior, dimos nuestros primeros pasos en el mundo de Zig. Hoy, vamos a adentrarnos en el corazÃ³n de la gestiÃ³n de proyectos de Zig: el sistema de construcciÃ³n de Zig. Â¡Empecemos! ğŸ‰\nÂ¿QuÃ© es el sistema de construcciÃ³n de Zig? ğŸ¤” El sistema de construcciÃ³n de Zig es una herramienta poderosa e incorporada que te ayuda a gestionar, compilar, probar y enlazar tus proyectos.","title":"Una guÃ­a del sistema de construcciÃ³n de Zig ğŸ—ï¸"},{"content":"Â¡Saludos, entusiastas de Zig! ğŸ‘‹ Es el momento de configurar un entorno de desarrollo cÃ³modo para mejorar tu experiencia de programaciÃ³n en Zig. En esta publicaciÃ³n, te guiarÃ© para configurar Visual Studio Code (VS Code) para el desarrollo en Zig, incluyendo ediciÃ³n de cÃ³digo, ejecuciÃ³n y depuraciÃ³n. Â¡SumÃ©rgete en el tema! ğŸš€\nConfigurando Visual Studio Code para el desarrollo en Zig ğŸ› ï¸ Para configurar VS Code para el desarrollo en Zig, sigue estos pasos:\nInstala Visual Studio Code: Si aÃºn no lo has hecho, descarga e instala Visual Studio Code para tu plataforma (Linux, Windows o macOS).\nInstala la extensiÃ³n de Zig: Abre el buscador rÃ¡pido de VS Code (Ctrl+P), pega el siguiente comando y presiona enter.\next install ziglang.vscode-zig Configura los ajustes: Para configurar los ajustes de la extensiÃ³n de Zig, abre el editor de ConfiguraciÃ³n haciendo clic en el Ã­cono de engranaje en la esquina inferior izquierda de la ventana y selecciona \u0026ldquo;ConfiguraciÃ³n\u0026rdquo;. Busca \u0026ldquo;Zig\u0026rdquo; en la barra de bÃºsqueda y actualiza los ajustes segÃºn sea necesario. Por ejemplo, es posible que desees establecer la ruta del compilador de Zig si no estÃ¡ en la ubicaciÃ³n predeterminada. Â¡Listo! Ahora estÃ¡s listo para desarrollar en Zig en VS Code. ğŸ‰\nEjecutando y depurando cÃ³digo ğŸƒâ€â™€ï¸ğŸ’» Para ejecutar y depurar cÃ³digo Zig en VS Code, sigue estos pasos:\nCrea un nuevo archivo Zig: Abre VS Code y crea un nuevo archivo con la extensiÃ³n .zig, como main.zig.\nEscribe cÃ³digo Zig: Escribe un programa sencillo en Zig en tu nuevo archivo, como un programa \u0026ldquo;Hola, mundo\u0026rdquo;:\nâš ï¸ Â¡AtenciÃ³n, programador! Este post utiliza la versiÃ³n dev 0.11.0 de Zig\nconst std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { std.debug.print(\u0026#34;Hello, {s}!\\n\u0026#34;, .{\u0026#34;World\u0026#34;}); } Configura tasks.json: Para ejecutar tu cÃ³digo Zig, necesitas crear un archivo tasks.json en la carpeta .vscode de tu espacio de trabajo. Agrega la siguiente configuraciÃ³n al archivo: { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;zig build-exe main.zig\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;build\u0026#34; } ] } Este archivo de configuraciÃ³n define tareas para Visual Studio Code. Las tareas se utilizan para automatizar el proceso de construcciÃ³n, prueba y despliegue de tu aplicaciÃ³n. En este caso, estamos definiendo la tarea de compilaciÃ³n:\n\u0026quot;label\u0026quot;: \u0026quot;build\u0026quot; - Es el nombre que se le da a la tarea. En este caso, la tarea se llama \u0026ldquo;build\u0026rdquo;. \u0026quot;type\u0026quot;: \u0026quot;shell\u0026quot; - Especifica que esta tarea se ejecutarÃ¡ en una shell o terminal. \u0026quot;command\u0026quot;: \u0026quot;zig build-exe main.zig\u0026quot; - Es el comando que se ejecutarÃ¡ cuando se inicie esta tarea. Este comando compilarÃ¡ el archivo main.zig en un ejecutable utilizando el compilador Zig. \u0026quot;group\u0026quot;: \u0026quot;build\u0026quot; - Esto agrupa la tarea en la categorÃ­a \u0026ldquo;build\u0026rdquo;. Las tareas se pueden agrupar para un fÃ¡cil acceso y gestiÃ³n en Visual Studio Code. Ejecuta tu cÃ³digo Zig: Presiona Ctrl+Shift+B (o Cmd+Shift+B en macOS) para ejecutar la tarea \u0026ldquo;build\u0026rdquo;, que compila tu cÃ³digo Zig. Salida:\n* Executing task: zig build-exe \u0026lt;...\u0026gt;/main.zig * Terminal will be reused by tasks, press any key to close it. DepuraciÃ³n: Para depurar tu cÃ³digo Zig, primero debes instalar las extensiones \u0026ldquo;Native Debug\u0026rdquo; de WebFreak y \u0026ldquo;CodeLLDB\u0026rdquo; de Vadim Chugunov. Presiona ctrl-p (cmd+p en macOS) y ejecuta los siguientes comandos:\next install webfreak.debug y\next install vadimcn.vscode-lldb Una vez instaladas, crea un archivo launch.json en la carpeta .vscode de tu espacio de trabajo con la siguiente configuraciÃ³n:\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Debug Zig\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;lldb\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;main\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;preLaunchTask\u0026#34;: \u0026#34;build\u0026#34; } ] } Este archivo de configuraciÃ³n de lanzamiento se usa para definir cÃ³mo se debe depurar un proyecto. El campo configurations tiene una lista de diferentes configuraciones de depuraciÃ³n que puedes usar. Puedes cambiar entre estas configuraciones en el menÃº desplegable de depuraciÃ³n en la parte superior de VS Code. La configuraciÃ³n se define asÃ­:\nname: Es el nombre que aparece en el menÃº desplegable de depuraciÃ³n. En este caso, estÃ¡ configurado como \u0026ldquo;Debug Zig\u0026rdquo;, lo que indica que esta configuraciÃ³n es para depurar programas escritos en Zig. type: Define el depurador que se utilizarÃ¡. En este caso, \u0026ldquo;lldb\u0026rdquo; indica que se utilizarÃ¡ el depurador LLDB de LLVM. request: Puede ser \u0026ldquo;launch\u0026rdquo; o \u0026ldquo;attach\u0026rdquo;. \u0026ldquo;launch\u0026rdquo; inicia el programa en el depurador, mientras que \u0026ldquo;attach\u0026rdquo; se conecta a un proceso ya en ejecuciÃ³n. En la configuraciÃ³n el valor es \u0026ldquo;launch\u0026rdquo;, por lo que el depurador iniciarÃ¡ el programa. program: Es el nombre del programa que se va a iniciar. En esta configuraciÃ³n, el valor es \u0026ldquo;main\u0026rdquo;, por lo que se espera un ejecutable llamado \u0026ldquo;main\u0026rdquo; en tu directorio de trabajo actual. args: Es una lista de argumentos que se pasarÃ¡n al programa cuando se lance. En tu caso, esta lista estÃ¡ vacÃ­a, por lo que no se pasarÃ¡n argumentos. cwd: Especifica el directorio de trabajo actual cuando se inicia el programa. \u0026ldquo;${workspaceFolder}\u0026rdquo; es una variable que se refiere al directorio raÃ­z de tu espacio de trabajo actual en VS Code. preLaunchTask: Es el nombre de una tarea definida en tasks.json que se ejecutarÃ¡ antes de que se lance el programa. Este es solo un ejemplo de configuraciÃ³n de depuraciÃ³n. La configuraciÃ³n exacta puede variar segÃºn el lenguaje de programaciÃ³n y el entorno de desarrollo especÃ­ficos que estÃ©s utilizando.\nDepura tu cÃ³digo Zig: Establece puntos de interrupciÃ³n en tu cÃ³digo Zig haciendo clic en el margen izquierdo junto a los nÃºmeros de lÃ­nea. Presiona F5 para iniciar la depuraciÃ³n. El depurador se detendrÃ¡ en tus puntos de interrupciÃ³n, lo que te permitirÃ¡ inspeccionar variables, avanzar paso a paso en tu cÃ³digo y utilizar otras funciones de depuraciÃ³n. Â¡Eso es todo! Ahora has configurado Visual Studio Code para el desarrollo en Zig, incluyendo la ejecuciÃ³n, asistencia y depuraciÃ³n de tu cÃ³digo. ğŸ‰\nÂ¿QuÃ© mÃ¡s? ğŸŒŸ Con tu flamante entorno de desarrollo Zig, estÃ¡s listo para explorar temas avanzados de Zig y crear proyectos asombrosos. Â¡Mantente atento a mÃ¡s publicaciones en el blog sobre conceptos avanzados de Zig!\nÂ¡Sigamos explorando el mundo de Zig juntos! ğŸ‘©â€ğŸ’»ğŸ‘¨â€ğŸ’»ğŸ¨\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/configura-visual-studio-code-para-programar-en-zig/","summary":"Â¡Saludos, entusiastas de Zig! ğŸ‘‹ Es el momento de configurar un entorno de desarrollo cÃ³modo para mejorar tu experiencia de programaciÃ³n en Zig. En esta publicaciÃ³n, te guiarÃ© para configurar Visual Studio Code (VS Code) para el desarrollo en Zig, incluyendo ediciÃ³n de cÃ³digo, ejecuciÃ³n y depuraciÃ³n. Â¡SumÃ©rgete en el tema! ğŸš€\nConfigurando Visual Studio Code para el desarrollo en Zig ğŸ› ï¸ Para configurar VS Code para el desarrollo en Zig, sigue estos pasos:","title":"Configura Visual Studio Code para programar en Zig ğŸ¨"},{"content":"Â¡Hola, entusiastas de Zig! ğŸ‘‹ En la publicaciÃ³n anteriores hemos visto que Zig mola mucho. Pero antes de sumergirnos en temas mÃ¡s avanzados, vamos a asegurarnos de tener Zig instalado y funcionando en nuestros sistemas. En esta publicaciÃ³n, te guiarÃ© en la instalaciÃ³n de Zig en Linux, Windows y macOS. Â¡Comencemos! ğŸš€\nInstalando Zig en Linux ğŸ§ âš ï¸ Â¡AtenciÃ³n, programador! Este post utiliza la versiÃ³n dev 0.11.0 de Zig\nPara usuarios de Linux, puedes instalar Zig utilizando los paquetes precompilados o construyÃ©ndolo desde el cÃ³digo fuente.\nPaquetes precompilados: Descarga el paquete apropiado para tu distribuciÃ³n de Linux desde la pÃ¡gina oficial de descargas de Zig. Extrae el archivo y agrega el binario zig a tu PATH.\nConstruir desde el cÃ³digo fuente: Si prefieres construir Zig desde el cÃ³digo fuente, sigue estos pasos:\nInstala las dependencias necesarias: build-essential, cmake y git. Clona el repositorio de Zig: git clone https://github.com/ziglang/zig.git Cambia al directorio clonado: cd zig Crea un directorio de construcciÃ³n: mkdir build \u0026amp;\u0026amp; cd build Ejecuta CMake para configurar la construcciÃ³n: cmake .. Construye Zig: make Agrega el binario zig a tu PATH. Una forma alternativa es usar snap: snap install --edge zig --classic\nInstalando Zig en Windows ğŸ’» Para usuarios de Windows, puedes instalar Zig utilizando los paquetes precompilados o el administrador de paquetes Scoop.\nPaquetes precompilados: Descarga el paquete apropiado para tu sistema desde la pÃ¡gina oficial de descargas de Zig. Extrae el archivo y agrega el binario zig a tu PATH.\nScoop: Si tienes Scoop instalado, puedes instalar Zig ejecutando: scoop install zig\nInstalando Zig en macOS ğŸ Para usuarios de macOS, puedes instalar Zig utilizando los paquetes precompilados, Homebrew o MacPorts.\nPaquetes precompilados: Descarga el paquete apropiado para tu sistema desde la pÃ¡gina oficial de descargas de Zig. Extrae el archivo y agrega el binario zig a tu PATH.\nHomebrew: Si tienes Homebrew instalado, puedes instalar Zig ejecutando: brew install zig\nMacPorts: Si tienes MacPorts instalado, puedes instalar Zig ejecutando: sudo port install zig\nÂ¡Listo! Ahora deberÃ­as tener Zig instalado en tu sistema Linux, Windows o macOS. ğŸ‰\nÂ¿QuÃ© mÃ¡s? ğŸŒŸ Con Zig instalado, estÃ¡s listo para explorar temas mÃ¡s avanzados y aprovechar todo el potencial de este emocionante lenguaje.\nÂ¡Ãnimo programador!\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/instalando-zig-en-linux-windows-y-macos/","summary":"Â¡Hola, entusiastas de Zig! ğŸ‘‹ En la publicaciÃ³n anteriores hemos visto que Zig mola mucho. Pero antes de sumergirnos en temas mÃ¡s avanzados, vamos a asegurarnos de tener Zig instalado y funcionando en nuestros sistemas. En esta publicaciÃ³n, te guiarÃ© en la instalaciÃ³n de Zig en Linux, Windows y macOS. Â¡Comencemos! ğŸš€\nInstalando Zig en Linux ğŸ§ âš ï¸ Â¡AtenciÃ³n, programador! Este post utiliza la versiÃ³n dev 0.11.0 de Zig\nPara usuarios de Linux, puedes instalar Zig utilizando los paquetes precompilados o construyÃ©ndolo desde el cÃ³digo fuente.","title":"Instalando Zig en Linux, Windows y macOS ğŸŒ"},{"content":"Â¡Bienvenido al emocionante mundo de Zig! ğŸš€ Si estÃ¡s buscando un lenguaje de programaciÃ³n que combine eficiencia, seguridad y un enfoque en el rendimiento, Â¡has llegado al lugar correcto!\nÂ¿Por quÃ© Zig? ğŸ¯ Una de las primeras cosas que notarÃ¡s al explorar Zig es su enfoque en la seguridad y la prevenciÃ³n de errores. El compilador de Zig es estricto y te ayudarÃ¡ a detectar problemas en tiempo de compilaciÃ³n antes de que se conviertan en pesadillas en tiempo de ejecuciÃ³n. Esto no solo te brinda una mayor confianza en la calidad de tu cÃ³digo, sino que tambiÃ©n te enseÃ±a buenas prÃ¡cticas para evitar errores comunes.\nPero Zig no se detiene solo en la seguridad. Si te apasiona la programaciÃ³n de alto rendimiento y quieres escribir cÃ³digo que aproveche al mÃ¡ximo los recursos del sistema, Zig es el lenguaje adecuado para ti. Su sintaxis limpia y elegante te permite escribir cÃ³digo eficiente y optimizado sin sacrificar la legibilidad.\nAdemÃ¡s, aprender Zig te brinda la oportunidad de adentrarte en el mundo de la programaciÃ³n de bajo nivel. Con Zig, puedes acceder directamente a la memoria y tener un control preciso sobre los recursos del sistema. Esto es especialmente Ãºtil si estÃ¡s interesado en desarrollar aplicaciones de sistemas embebidos, controladores de dispositivos o soluciones de bajo nivel.\nZig tambiÃ©n es una excelente opciÃ³n para aquellos que estÃ¡n aprendiendo a programar. A travÃ©s de Zig, puedes adquirir una comprensiÃ³n sÃ³lida de los conceptos fundamentales de la programaciÃ³n, como el control de flujo, las estructuras de datos y los algoritmos. Al mismo tiempo, ampliarÃ¡s tu perspectiva sobre la programaciÃ³n y desarrollarÃ¡s habilidades valiosas para el futuro.\nNo te voy a engaÃ±ar: Zig a veces muerde ğŸ˜¬, pero eso es bueno. Es un lenguage en plena creaciÃ³n y evoluciona muy rÃ¡pidamente con cambios incompatibles y bugs. AdemÃ¡s su determinado enfoque en la seguridad te obliga a ser consciente de muchos aspectos que en otros lenguages simplemente se ignoran (el precio se paga despuÃ©s). Pero no temas programador, Â¡todo eso te harÃ¡ mas fuerte!.ğŸ’ª\nÂ¡Hola, mundo! ğŸ‘‹ Como en cualquier lenguaje, el primer paso es escribir un clÃ¡sico \u0026ldquo;Hola, mundo\u0026rdquo; en Zig para ver quÃ© pinta tiene y quÃ© sensaciones te produce:\nâš ï¸ Â¡AtenciÃ³n, programador! Este post utiliza la versiÃ³n dev 0.11.0 de Zig\n//zig version: 0.11.0-dev.3191+fd213accb const std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { const stdout = std.io.getStdOut().writer(); try stdout.print(\u0026#34;Â¡Hola, mundo!\\n\u0026#34;,.{}); } Es muy poco cÃ³digo pero ya se pueden observar algunas caracterÃ­sticas del lenguaje Zig:\nEnfoque en la seguridad: El uso de la declaraciÃ³n try para manejar errores de manera explÃ­cita demuestra la preocupaciÃ³n por la seguridad y la prevenciÃ³n de errores en Zig.\nSintaxis limpia y legible: La sintaxis del programa es clara y fÃ¡cil de entender, lo que facilita la lectura y escritura de cÃ³digo en Zig.\nManejo explÃ­cito de recursos: Al obtener el escritor de salida estÃ¡ndar a travÃ©s de getStdOut(), Zig enfatiza el manejo explÃ­cito de recursos, permitiendo un control mÃ¡s preciso y seguro.\nOrientaciÃ³n a bajo nivel: Zig permite acceder directamente a la memoria y proporciona un mayor control sobre los recursos del sistema, lo que es Ãºtil en situaciones de programaciÃ³n de bajo nivel.\nEnfoque en el rendimiento: Zig estÃ¡ diseÃ±ado para ofrecer un rendimiento excepcional, lo que se refleja en la eficiencia del programa \u0026ldquo;Hello, World\u0026rdquo;.\nEstas cualidades son solo una pequeÃ±a muestra de las fortalezas de Zig como lenguaje de programaciÃ³n. A medida que te adentres en Zig, descubrirÃ¡s muchas mÃ¡s ventajas que te ayudarÃ¡n a desarrollar software eficiente y confiable.\nOtro ejemplo, un poco mÃ¡s completo, tiene esta pinta:\n//zig version: 0.11.0-dev.3191+fd213accb const std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { // Prints to stderr (it\u0026#39;s a shortcut based on `std.io.getStdErr()`) std.debug.print(\u0026#34;All your {s} are belong to us.\\n\u0026#34;, .{\u0026#34;codebase\u0026#34;}); // stdout is for the actual output of your application, for example if you // are implementing gzip, then only the compressed bytes should be sent to // stdout, not any debugging messages. const stdout_file = std.io.getStdOut().writer(); var bw = std.io.bufferedWriter(stdout_file); const stdout = bw.writer(); try stdout.print(\u0026#34;Run `zig build test` to run the tests.\\n\u0026#34;, .{}); try bw.flush(); // don\u0026#39;t forget to flush! } test \u0026#34;simple test\u0026#34; { var list = std.ArrayList(i32).init(std.testing.allocator); defer list.deinit(); // try commenting this out and see if zig detects the memory leak! try list.append(42); try std.testing.expectEqual(@as(i32, 42), list.pop()); } Me gusta, Â¿CÃ³mo aprendo? ğŸ“šğŸ’¡ La documentaciÃ³n oficial de Zig es un excelente punto de partida. Puedes acceder a ella en el sitio web oficial de Zig y encontrarÃ¡s una guÃ­a detallada, ejemplos de cÃ³digo, tutoriales y una descripciÃ³n completa de la biblioteca estÃ¡ndar. La documentaciÃ³n oficial es constantemente actualizada y es una fuente confiable para comprender la sintaxis, las caracterÃ­sticas del lenguaje y las mejores prÃ¡cticas. Recuerda, consulta siempre la documentaciÃ³n de la versiÃ³n de Zig que estÃ©s utilizando, porque puede variar mucho de una a otra.\nEl repositorio oficial de Zig en GitHub es una fuente invaluable de cÃ³digo fuente abierto en Zig. Puedes explorar proyectos de la comunidad, estudiar el cÃ³digo existente y aprender de ejemplos prÃ¡cticos. TambiÃ©n puedes contribuir a proyectos existentes o incluso iniciar tus propios proyectos en Zig.\nAdemÃ¡s de GitHub, el subreddit de Zig y el canal de Discord oficial de Zig son excelentes lugares para conectarte con otros programadores de Zig, hacer preguntas, compartir conocimientos y obtener ayuda. Estos espacios de la comunidad estÃ¡n llenos de personas amigables y conocedoras que estÃ¡n dispuestas a ayudarte en tu viaje de aprendizaje en Zig.\nRecuerda que la prÃ¡ctica es fundamental para dominar cualquier lenguaje de programaciÃ³n. A medida que adquieras conocimientos, te recomiendo implementar proyectos pequeÃ±os y desafiantes por tu cuenta. Esto te permitirÃ¡ aplicar lo que has aprendido, experimentar con difer\nY por supuesto Â¡sigue este blog!. Te llevarÃ© a un emocionante viaje a travÃ©s del mundo de Zig. CompartirÃ© tutoriales, consejos Ãºtiles, trucos y experiencias personales mientras exploramos juntos las maravillas y desafÃ­os de este increÃ­ble lenguaje de programaciÃ³n. Desde los conceptos bÃ¡sicos hasta tÃ©cnicas avanzadas, encontrarÃ¡s contenido fresco y relevante para mejorar tus habilidades en Zig.\nAhora empieza todo Â¡No te pierdas ninguno de los nuevos artÃ­culos de \u0026ldquo;Zig-zagueando\u0026rdquo;! Puedes suscribirte al blog mediante el clÃ¡sico y eficiente RSS ğŸ“° para recibir notificaciones cada vez que publique una nueva entrada. AdemÃ¡s, te invito a participar en los comentarios, compartir tus propias experiencias y hacer preguntas sobre cualquier tema relacionado con Zig.\nÂ¡PrepÃ¡rate para disfrutar de un blog lleno de conocimientos, diversiÃ³n y aventuras en Zig! Â¡Nos vemos, valiente programador!\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/zig-un-lenguaje-de-programaci%C3%B3n-simple-y-potente/","summary":"Â¡Bienvenido al emocionante mundo de Zig! ğŸš€ Si estÃ¡s buscando un lenguaje de programaciÃ³n que combine eficiencia, seguridad y un enfoque en el rendimiento, Â¡has llegado al lugar correcto!\nÂ¿Por quÃ© Zig? ğŸ¯ Una de las primeras cosas que notarÃ¡s al explorar Zig es su enfoque en la seguridad y la prevenciÃ³n de errores. El compilador de Zig es estricto y te ayudarÃ¡ a detectar problemas en tiempo de compilaciÃ³n antes de que se conviertan en pesadillas en tiempo de ejecuciÃ³n.","title":"Zig: Un lenguaje de programaciÃ³n simple y potente ğŸš€"}]