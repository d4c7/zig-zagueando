[{"content":"¬°Hola de nuevo! üôå Esperamos que est√©s emocionado por continuar con el desarrollo de nuestro analizador de argumentos de l√≠nea de comandos, zig-argueando. En esta segunda parte, nos enfocaremos en crear la estructura b√°sica de nuestra biblioteca. Empecemos.\nDise√±ando la estructura de datos de los argumentos üìù Necesitamos una estructura de datos que represente un argumento de l√≠nea de comandos y vamos a dedicarle un tiempo sustancial. Comprendo que puedes estar pensando, \u0026ldquo;¬øPor qu√© deber√≠a pasar tanto tiempo pensando en estructuras de datos cuando hay tanto c√≥digo que escribir?\u0026rdquo; Cr√©eme, he estado all√≠. Pero a trav√©s de los a√±os he aprendido que las estructuras de datos son fundamentales por varias razones:\nEficiencia: Las estructuras de datos correctas pueden hacer una gran diferencia en la eficiencia de tu aplicaci√≥n. A veces, la diferencia entre un algoritmo O(n^2) y uno O(n log n) es simplemente la elecci√≥n de la estructura de datos adecuada. Una decisi√≥n temprana y consciente puede evitar muchos problemas de rendimiento en el futuro.\nOrganizaci√≥n: El dise√±o de las estructuras de datos afecta a la organizaci√≥n de tu c√≥digo. Una buena estructura de datos puede facilitar la lectura y la comprensi√≥n del c√≥digo, haciendo que sea m√°s f√°cil de mantener y extender.\nAbstracci√≥n: Las estructuras de datos nos permiten abstraer detalles complicados y centrarnos en problemas de alto nivel. Por ejemplo, no necesitamos saber exactamente c√≥mo funciona una tabla hash para beneficiarnos de su capacidad para buscar elementos en tiempo constante.\nModelado de datos: Las estructuras de datos son una forma de modelar la realidad en nuestros programas. Un buen modelo de datos puede facilitar la resoluci√≥n de problemas y hacer que nuestro c√≥digo sea m√°s flexible y adaptable a los cambios.\nPor eso es importante dedicarle tiempo desde el principio. No es solo por el hecho de \u0026ldquo;hacerlo bien\u0026rdquo; desde el comienzo. Es tambi√©n por las consecuencias a largo plazo que pueden surgir si no se toma en cuenta. Las estructuras de datos mal elegidas pueden resultar en c√≥digo lento, dif√≠cil de entender y de mantener, e incluso incorrecto.\nEs cierto que el desarrollo de software, despu√©s de todo, es un proceso iterativo. Puedes comenzar con una estructura de datos inicial simple que cumpla con los requisitos b√°sicos de tu aplicaci√≥n. A medida que tu aplicaci√≥n crece y evoluciona, podr√≠as encontrarte en la necesidad de revisar y ajustar estas estructuras para acomodar nuevas caracter√≠sticas o mejorar el rendimiento.\nSin embargo, quiero a√±adir una nota de precauci√≥n aqu√≠: este camino puede ser realmente arduo. Cambiar la estructura de datos fundamental de un programa en funcionamiento puede ser un proceso complicado y propenso a errores. Podr√≠as tener que reescribir grandes partes de tu c√≥digo y hacer un extenso trabajo de pruebas para asegurarte de que todo sigue funcionando como se espera.\nNo quiero desalentarte de hacer iteraciones sobre tus estructuras de datos, pero s√≠ es importante tener en cuenta que un poco de tiempo invertido en la planificaci√≥n inicial puede ahorrar mucho tiempo y dolores de cabeza m√°s adelante. Es un equilibrio delicado, ¬øverdad? Pero esa es parte de la belleza y el desaf√≠o de nuestra profesi√≥n.\nEn Zig, utilizaremos struct para definir nuestros modelos de datos. En nuestro modelo, vamos a representar par√°metros que pueden ser de tipo option o positional. Los argumentos de tipo option pueden tener un nombre corto y otro largo.\n‚ö†Ô∏è ¬°Atenci√≥n, programador! Este post utiliza la versi√≥n 0.11.0-dev.3971 de Zig\nconst Param = struct { kind: Kind, tag: usize = 0, help: []const u8 = \u0026#34;\u0026#34;, check: ?*const Checks.Fn = null, }; const Kind = union(KindTag) { option: Option, positional: Positional, }; const Option = struct { format: Format = .flag, short: []const u8 = \u0026#34;\u0026#34;, long: []const u8 = \u0026#34;\u0026#34;, }; pub const Positional = struct { format: Format, }; Ambos tipos de par√°metros definen un formato format que puede ser flag, single o multi representado par√°metros tipo flag, que s√≥lo pueden aparecer una vez o m√∫ltiples veces respectivamente. El formato, si no es flag, especifica un parser para convertir el argumento en un tipo de datos concreto. Adem√°s los par√°metros pueden establecer una funci√≥n personalizada de validaci√≥n y definir el texto que aparecer√° en la ayuda.\nconst Format = union(FormatTag) { flag: void, single: Single, multi: Multi, }; pub const Single = struct { parser: []const u8 = \u0026#34;STR\u0026#34;, default: ?[]const u8 = null, }; pub const Multi = struct { parser: []const u8 = \u0026#34;STR\u0026#34;, defaults: ?[]const []const u8 = null, min: usize = 1, max: usize = 1, }; Un parser permite convertir y validar un argumento en texto a un tipo concreto en Zig. Para ello definimos dos punteros funciones, uno para realizar el parsing en s√≠ y el otro para validar el valor obtenido. Adem√°s podremos definir el texto que aparecer√° en la ayuda.\nTodos los elementos anteriores forman parte de la estructura principal CommandLineParser que incluye la lista de parsers y param√©tros, as√≠ como los texto de ayuda que incluyen cabecera, pie y descripci√≥n; y por supuesto las opciones de procesado.\nImplementando la funci√≥n de an√°lisis de argumentos üí° Con la estructura b√°sica en su lugar, es hora de implementar la funci√≥n del CommandLineParser que analizar√° los argumentos. Esta funci√≥n tomar√° la lista de argumentos proporcionada por el usuario (normalmente a trav√©s de std.process.args()) y llenar√° la estructura de datos Args.\npub fn parseArgs(comptime self: CommandLineParser, allocator: std.mem.Allocator) Args(self) { var it = try std.process.ArgIterator.initWithAllocator(allocator); defer it.deinit(); return self.parse(\u0026amp;it, allocator); } La funci√≥n parseArgs recibe una lista de argumentos y procesa cada uno de ellos en orden. Si encuentra un argumento que no reconoce, o si se proporciona un valor para un argumento que no lo requiere, registra un problema. Si todo va bien, devuelve la estructura de datos Args llena con la informaci√≥n recopilada.\nLa estructura Args, que recibe el resultado del an√°lisis de la l√≠nea de comandos, contiene:\nexe, que tiene el nombre del ejecutable args, que contiene una estructura con los nombres de las opciones y otro campo especial positionals con los argumentos posicionales problems, es una lista de problemas encontrados durante el an√°lisis de los argumentos En este punto hay que hacer notar que todas las estructuras CommandLineParser, Args se han crean en tiempo de compilaci√≥n. ¬°Fant√°stico!\nUsando las estructuras üõ† Zig-argueando propociona funciones con valores por defecto para inicializar las estructuras, de esta forma obtenemos muchas ventajas:\nPodemos mantener una interface m√°s estable y simple al usuario. Podemos modificar estructuras internas sin que nuestros usuarios tengan que cambiar el c√≥digo Es m√°s sencillo inicializar las estructuras porque tienen valores predefinidos \u0026ldquo;v√°lidos\u0026rdquo; Las estructuras no admiten campos que no sean relevantes para el objeto que se define Por ejemplo, para definir un par√°metro que es un flag se proporciona la funci√≥n flag, que admite una estructura que tiene preestablecidos sus campos:\npub const DefaultFlag = struct { short: []const u8 = \u0026#34;\u0026#34;, long: []const u8 = \u0026#34;\u0026#34;, help: []const u8 = \u0026#34;\u0026#34;, }; pub fn flag(comptime opts: DefaultFlag) Param { return Param{ .kind = .{ .option = .{ .short = opts.short, .long = opts.long, .format = .flag, } }, .help = opts.help, }; } Es muy f√°cil ahora definir un par√°metro tipo flag que tenga como nombre largo --verbose y corto -v, con su correspondiente texto de ayuda:\nflag(.{ .long = \u0026#34;verbose\u0026#34;, .short = \u0026#34;v\u0026#34;, .help = \u0026#34;Enable verbose output.\u0026#34; }), As√≠ proporcionamos funciones para definir par√°metros flag, flagHelp, option, multiOption, singlePositional y multiPositional, y qui√©n sabe si alguno m√°s en el futuro.\nEsto permite definir los analizadores de una manera muy intuitiva a nuestro usuarios. En muchas ocasiones, la simplicidad para los usuarios es nuestra complejidad:\nconst clp = comptime Argueando.CommandLineParser.init(.{ .header= \\\\ \\ | \\\\ _ \\ __| _` | | | _ \\ _` | __ \\ _` | _ \\ \\\\ ___ \\ | ( | | | __/ ( | | | ( | ( | \\\\_/ _\\ _| \\__, | \\__,_| \\___| \\__,_| _| _| \\__,_| \\___/ \\\\ |___/ ,.params = \u0026amp;[_]Argueando.Param{ flagHelp(.{ .long = \u0026#34;help\u0026#34;, .short = \u0026#34;h\u0026#34;, .help = \u0026#34;Shows this help.\u0026#34; }), flag(.{ .long = \u0026#34;version\u0026#34;, .help = \u0026#34;Output version information and exit.\u0026#34; }), flag(.{ .long = \u0026#34;verbose\u0026#34;, .short = \u0026#34;v\u0026#34;, .help = \u0026#34;Enable verbose output.\u0026#34; }), option(.{ .long = \u0026#34;port\u0026#34;, .short = \u0026#34;p\u0026#34;, .parser = \u0026#34;TCP_PORT\u0026#34;, .default = \u0026#34;1234\u0026#34;, .help = \u0026#34;Listening Port.\u0026#34; }), option(.{ .long = \u0026#34;host\u0026#34;, .short = \u0026#34;H\u0026#34;, .parser = \u0026#34;TCP_HOST\u0026#34;, .default = \u0026#34;localhost\u0026#34;, .help = \u0026#34;Host name\u0026#34; }), singlePositional(.{ .parser = \u0026#34;DIR\u0026#34;, .default = \u0026#34;.\u0026#34;, .check = \u0026amp;Check.Dir(.{ .mode = .read_only }).f }), }, // .desc = \u0026#34;This command starts an HTTP Server and serves static content from directory DIR.\u0026#34;, // .footer = \u0026#34;More info: \u0026lt;https://d4c7.github.io/zig-zagueando/\u0026gt;.\u0026#34;, }); var s = clp.parseArgs(allocator); defer s.deinit(); if (s.helpRequested()) { try s.printHelp(std.io.getStdErr().writer()); return; } if (s.hasProblems()) { try s.printProblems(std.io.getStdErr().writer(), .AllProblems); return; } $ ./sample-argueando --help \\ | _ \\ __| _` | | | _ \\ _` | __ \\ _` | _ \\ ___ \\ | ( | | | __/ ( | | | ( | ( | _/ _\\ _| \\__, | \\__,_| \\___| \\__,_| _| _| \\__,_| \\___/ |___/ Usage: sample-argueando [(-h|--help)] [--version] [(-v|--verbose)] [(-p|--port)=TCP_PORT] [(-H|--host)=TCP_HOST] [DIR] This command starts an HTTP Server and serves static content from directory DIR. -h, --help Shows this help. --version Output version information and exit. -v, --verbose Enable verbose output. -p, --port=TCP_PORT Listening Port. Default value: 1234 -H, --host=TCP_HOST Host name Default value: localhost TCP_PORT TCP port value between 0 and 65535. Use port 0 to dynamically assign a port Can use base prefix (0x,0o,0b). TCP_HOST TCP host name or IP. DIR Directory More info: \u0026lt;https://d4c7.github.io/zig-zagueando/\u0026gt;. Conclusiones de la Segunda Parte ‚ú® Hemos definido los modelos de datos de nuestra biblioteca zig-argueando. Puedes ver c√≥digo en desarrollo de la librer√≠a en GitHub, que iremos mejorando, analizando y explicando poco a poco. ¬°Hasta la pr√≥xima! üëã\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/un-analizador-de-linea-de-comandos-en-zig-2/","summary":"¬°Hola de nuevo! üôå Esperamos que est√©s emocionado por continuar con el desarrollo de nuestro analizador de argumentos de l√≠nea de comandos, zig-argueando. En esta segunda parte, nos enfocaremos en crear la estructura b√°sica de nuestra biblioteca. Empecemos.\nDise√±ando la estructura de datos de los argumentos üìù Necesitamos una estructura de datos que represente un argumento de l√≠nea de comandos y vamos a dedicarle un tiempo sustancial. Comprendo que puedes estar pensando, \u0026ldquo;¬øPor qu√© deber√≠a pasar tanto tiempo pensando en estructuras de datos cuando hay tanto c√≥digo que escribir?","title":"Un analizador de l√≠nea de comandos en Zig üîß (Parte II)"},{"content":"¬°Hola a todos! üëã Hoy vamos a hablar de un tema muy interesante: c√≥mo analizar los argumentos de la l√≠nea de comandos. ¬°Prep√°rate para una profunda inmersi√≥n! üåäüèä‚Äç‚ôÇÔ∏è\nIntroducci√≥n a los Argumentos de la L√≠nea de Comandos üìù Los argumentos de la l√≠nea de comandos son una forma com√∫n de especificar opciones para programas ejecutables. Son especialmente √∫tiles para interactuar con tu programa de forma flexible y potente. En esencia, los argumentos de la l√≠nea de comandos son una lista de palabras que se pasan a un programa cuando se invoca. ¬øPero c√≥mo se manejan en Zig? ¬°Vamos a descubrirlo! üïµÔ∏è‚Äç‚ôÄÔ∏è\nArgumentos de la L√≠nea de Comandos en Zig üßÆ En Zig, la sintaxis para los argumentos de la l√≠nea de comandos es bastante sencilla. Cuando se inicia un programa, los argumentos de la l√≠nea de comandos se pasan como una matriz de cadenas. Puedes recuperar argumentos de la l√≠nea de comandos usando la estructura std.process.ArgIterator e inicializ√°ndola con initWithAllocator(allocator: Allocator) si queremos abstraernos de la plataforma. Con este iterador podemos recorrer los argumentos, pero a menudo necesitamos un poco m√°s de funcionalidad.\nvar it = try std.process.ArgIterator.initWithAllocator(allocator); defer it.deinit(); while (it.next()) |arg| { std.debug.print(\u0026#34;{s}\\n\u0026#34;, .{arg}); } Tambi√©n podemos usar std.process.ArgIterator.init() sin necesidad de allocator pero en la pr√°ctica la opci√≥n anterior es la m√°s recomendable, teniendo adem√°s en cuenta que el uso de un parsing m√°s sofisticado de los argumentos casi seguro requerir√° de un asignador de memoria.\nPr√≥ximamente: Aprende sobre allocators en el art√≠culo \u0026ldquo;Memoria en Zig\u0026rdquo;\nBibliotecas de an√°lisis Es cuando necesitamos m√°s funcionalidad cuando entran las bibliotecas de an√°lisis como \u0026lsquo;zig-clap\u0026rsquo; o \u0026lsquo;zig-args\u0026rsquo;:\nPr√≥ximamente: Aprende sobre el uso de librer√≠as en Zig en el art√≠culo \u0026ldquo;Las librer√≠as de Zig\u0026rdquo;\nzig-clap: Es una biblioteca simple y f√°cil de usar para el an√°lisis de argumentos de l√≠nea de comando en Zig. Ofrece caracter√≠sticas como argumentos cortos y largos, soporte para pasar valores usando espacios y \u0026lsquo;=\u0026rsquo;, opciones que pueden ser especificadas m√∫ltiples veces, impresi√≥n y an√°lisis de mensajes de ayuda a partir de especificaciones de par√°metros. En esencia le pasamos una definici√≥n en forma de texto de c√≥mo queremos parsear los argumentos y nos crear√° una estructura, en tiempo de compilaci√≥n, para esa definici√≥n. Luego rellenaremos una instancia de la estructura con las opciones y argumentos pasados al programa.\nAprende todo sobre tiempo de compilaci√≥n en \u0026ldquo;Zig comptime\u0026rdquo;\n‚ö†Ô∏è ¬°Atenci√≥n, programador! Este post utiliza la versi√≥n 0.11.0-dev.3971 de Zig\nconst params = comptime clap.parseParamsComptime( \\\\-h, --help Display this help and exit. \\\\-n, --number \u0026lt;usize\u0026gt; An option parameter, which takes a value. \\\\-s, --string \u0026lt;str\u0026gt;... An option parameter which can be specified multiple times. \\\\\u0026lt;str\u0026gt;... \\\\ ); var diag = clap.Diagnostic{}; var res = clap.parse(clap.Help, \u0026amp;params, clap.parsers.default, .{ .diagnostic = \u0026amp;diag, }) catch |err| { diag.report(std.io.getStdErr().writer(), err) catch {}; return err; }; defer res.deinit(); if (res.args.help != 0) return clap.help(std.io.getStdErr().writer(), clap.Help, \u0026amp;params, .{}); if (res.args.number) |n| std.debug.print(\u0026#34;--number = {}\\n\u0026#34;, .{n}); for (res.args.string) |s| std.debug.print(\u0026#34;--string = {s}\\n\u0026#34;, .{s}); std.debug.print(\u0026#34;positional arguments:\\n\u0026#34;, .{}); for (res.positionals) |pos| { std.debug.print(\u0026#34;{s}\\n\u0026#34;, .{pos}); } En \u0026lsquo;zig-clap\u0026rsquo;, puedes manejar casos m√°s complejos, como subcomandos o argumentos opcionales y definir tu propio parsing de argumentos con clap.parsers.default. üí°\nEs esencial manejar errores al analizar argumentos de la l√≠nea de comandos. En \u0026lsquo;zig-clap\u0026rsquo;, puedes usar la estructura Diagnostics para informar errores √∫tiles. üöë\nzig-args: Este es otro m√≥dulo de Zig para el an√°lisis de argumentos de l√≠nea de comando. Proporciona funciones para analizar argumentos para una especificaci√≥n dada y nuestro proceso actual, con opciones para manejar errores de an√°lisis. Tambi√©n permite el uso de un m√©todo \u0026lsquo;Verb\u0026rsquo;, lo que significa que el primer argumento posicional se interpreta como un verbo que puede ser considerado un subcomando que proporciona m√°s opciones espec√≠ficas. A diferencia de clap, definimos las opciones y argumentos en una estructura que se rellenar√° al analizar los argumentos.\nconst options = try argsParser.parseForCurrentProcess(struct { // This declares long options for double hyphen output: ?[]const u8 = null, @\u0026#34;with-offset\u0026#34;: bool = false, @\u0026#34;with-hexdump\u0026#34;: bool = false, @\u0026#34;intermix-source\u0026#34;: bool = false, numberOfBytes: ?i32 = null, signed_number: ?i64 = null, unsigned_number: ?u64 = null, mode: enum { default, special, slow, fast } = .default, // This declares short-hand options for single hyphen pub const shorthands = .{ .S = \u0026#34;intermix-source\u0026#34;, .b = \u0026#34;with-hexdump\u0026#34;, .O = \u0026#34;with-offset\u0026#34;, .o = \u0026#34;output\u0026#34;, }; }, allocator, .print); defer options.deinit(); if (options.executable_name) |exe| { std.debug.print(\u0026#34;executable name: {s}\\n\u0026#34;, .{exe}); } std.debug.print(\u0026#34;parsed options:\\n\u0026#34;, .{}); inline for (std.meta.fields(@TypeOf(options.options))) |fld| { std.debug.print(\u0026#34;\\t{s} = {any}\\n\u0026#34;, .{ fld.name, @field(options.options, fld.name), }); } std.debug.print(\u0026#34;parsed positionals:\\n\u0026#34;, .{}); for (options.positionals) |arg| { std.debug.print(\u0026#34;\\t\u0026#39;{s}\u0026#39;\\n\u0026#34;, .{arg}); } Nuestro propio analizador ü§ì Usar una biblioteca probada es lo que uno debe hacer normalmente y no inventar la rueda a la primera de cambio. Pero estamos aqu√≠ para aprender y divertirnos con Zig, as√≠ que no vamos a dejar pasar la oportunidad de implementar nuestro propio analizador de argumentos de l√≠nea de comando. ¬°S√≠, lo has o√≠do bien! üéâüéâ.\nAprender√°s una cantidad incre√≠ble en el proceso. Vas a entender mejor c√≥mo funcionan las cosas bajo el cap√≥, c√≥mo los argumentos pasan de la l√≠nea de comandos a tu programa y c√≥mo puedes manipularlos para hacer exactamente lo que quieres. ¬°Es como tener superpoderes! üí™üöÄ As√≠ que, poneros c√≥modos, preparaos una taza de vuestro caf√© o te favorito ‚òï y ¬°vamos a ello, creemos nuestra propia biblioteca de an√°lisis de argumentos de l√≠nea de comando: zig-argueando! üéØ\nConvenciones POSIX Nuestro analizado implementar√°, en general, las convenciones recomendadas por POSIX para los argumentos de la l√≠nea de comandos:\nLos argumentos son opciones cortas si comienzan con un delimitador de gui√≥n (-) m√°s un caracter alfanum√©ricos individuales u opviones largar si empiezan con doble gui√≥n (--) con un nombre largo. Varias opciones cortas pueden seguir a un delimitador de gui√≥n en un solo token si las opciones no toman argumentos. Por lo tanto, -abc es equivalente a -a -b -c. La √∫ltima opci√≥n si podr√° tener argumento. Algunas opciones requieren un argumento. Por ejemplo, la opci√≥n -o del comando ld requiere un argumento, un nombre de archivo de salida. Las opciones normalmente preceden a otros argumentos que no son opciones y que se llaman posicionales. Los argumentos de las opciones pueden ir en el mismo token si la opci√≥n y su argumento est√° separado por un separador. Por ejemplo, -a=foo o --name=value en lugar de -a foo o --name value Un argumento que es exactamente doble gui√≥n (--) indica que a partir de ese argumentos todos los dem√°s son posicionales. Un argumento que es exactamente un gui√≥n (-) se tratar√° como posicional. Suele indicar entrada o salida estandar. Las opciones se pueden suministrar en cualquier orden. Pero nos saldremos un poco de las convenciones en estos aspectos, por otra parte discutibles:\nUna opci√≥n y su argumento pueden aparecer o no como tokens separados. En otras palabras, el espacio en blanco que los separa es opcional. Por lo tanto, -o foo y -ofoo son equivalentes. Pero nuestro analizador no va a permitir esto ya que puede dar lugar a ambig√ºedades. Los nombres de las opciones deben escribirse completamente y daremos la opci√≥n como desconocida si es parcial aunque no haya conflicto. Si la opci√≥n es --host no podr√° escribirse como --hos, ni --ho, ni --h. Las opciones pueden aparecer varias veces pero s√≥lo si son opciones que lo permiten expl√≠citamente o tienen el mismo valor. Nada de la √∫ltima opci√≥n gana, buff. Necesitamos un plan Estos son una serie de tareas iniciales para dise√±ar un parser de l√≠nea de comandos en Zig:\nDise√±ar la estructura de datos de los argumentos\nDefine una estructura de datos que represente un argumento de l√≠nea de comandos. Esta estructura debe contener informaci√≥n como el nombre corto de la opci√≥n (si existe), el nombre largo (si existe), si la opci√≥n necesita un valor, y cualquier valor predeterminado o proporcionado por el usuario.\nImplementar la funci√≥n de an√°lisis de argumentos\nEsta funci√≥n deber√≠a tomar la lista de argumentos proporcionados por el usuario (generalmente a trav√©s de std.process.args()) y llenar la estructura de datos definida anteriormente. Debe ser capaz de manejar tanto argumentos cortos (-a) como largos (--arg), y debe manejar correctamente los argumentos que requieren valores (-o value o -o value o --option=value). Tambi√©n debe ser capaz de manejar el caso especial de --, que indica el final de los argumentos.\nImplementar el manejo de errores\nSi el usuario proporciona un argumento que no se reconoce, o si se proporciona un valor para un argumento que no requiere uno, el parser debe ser capaz de manejar esto de manera elegante. Esto puede incluir la generaci√≥n de mensajes de error √∫tiles.\nImplementar funciones de ayuda\nProporcionar funciones que generen autom√°ticamente mensajes de ayuda basados en las estructuras de argumentos definidas. Esto puede incluir una descripci√≥n del comando y de cada argumento, si se requiere un valor, y cualquier valor predeterminado.\nPruebas\nProbaremos completamente el parser de l√≠nea de comandos. Esto incluir√° pruebas para argumentos cortos y largos, argumentos con y sin valores, el indicador --, y el manejo de errores.\nFin de la primera parte üåü No te pierdas las siguientes partes donde comenzaremos a implementar el analizador explicando paso a paso lo que hacemos. ¬°Nos vemos! Un ejemplo de lo que vamos a programar:\nconst clp = comptime Argueando.CommandLineParser.init(.{ .header= \\\\ \\ | \\\\ _ \\ __| _` | | | _ \\ _` | __ \\ _` | _ \\ \\\\ ___ \\ | ( | | | __/ ( | | | ( | ( | \\\\_/ _\\ _| \\__, | \\__,_| \\___| \\__,_| _| _| \\__,_| \\___/ \\\\ |___/ ,.params = \u0026amp;[_]Argueando.Param{ flagHelp(.{ .long = \u0026#34;help\u0026#34;, .short = \u0026#34;h\u0026#34;, .help = \u0026#34;Shows this help.\u0026#34; }), flag(.{ .long = \u0026#34;version\u0026#34;, .help = \u0026#34;Output version information and exit.\u0026#34; }), flag(.{ .long = \u0026#34;verbose\u0026#34;, .short = \u0026#34;v\u0026#34;, .help = \u0026#34;Enable verbose output.\u0026#34; }), option(.{ .long = \u0026#34;port\u0026#34;, .short = \u0026#34;p\u0026#34;, .parser = \u0026#34;TCP_PORT\u0026#34;, .default = \u0026#34;1234\u0026#34;, .help = \u0026#34;Listening Port.\u0026#34; }), option(.{ .long = \u0026#34;host\u0026#34;, .short = \u0026#34;H\u0026#34;, .parser = \u0026#34;TCP_HOST\u0026#34;, .default = \u0026#34;localhost\u0026#34;, .help = \u0026#34;Host name\u0026#34; }), singlePositional(.{ .parser = \u0026#34;DIR\u0026#34;, .default = \u0026#34;.\u0026#34;, .check = \u0026amp;Check.Dir(.{ .mode = .read_only }).f }), }, // .desc = \u0026#34;This command starts an HTTP Server and serves static content from directory DIR.\u0026#34;, // .footer = \u0026#34;More info: \u0026lt;https://d4c7.github.io/zig-zagueando/\u0026gt;.\u0026#34;, }); var s = clp.parseArgs(allocator); defer s.deinit(); if (s.helpRequested()) { try s.printHelp(std.io.getStdErr().writer()); return; } if (s.hasProblems()) { try s.printProblems(std.io.getStdErr().writer(), .AllProblems); return; } \\ | _ \\ __| _` | | | _ \\ _` | __ \\ _` | _ \\ ___ \\ | ( | | | __/ ( | | | ( | ( | _/ _\\ _| \\__, | \\__,_| \\___| \\__,_| _| _| \\__,_| \\___/ |___/ Usage: sample-argueando [(-h|--help)] [--version] [(-v|--verbose)] [(-p|--port)=TCP_PORT] [(-H|--host)=TCP_HOST] [DIR] This command starts an HTTP Server and serves static content from directory DIR. -h, --help Shows this help. --version Output version information and exit. -v, --verbose Enable verbose output. -p, --port=TCP_PORT Listening Port. Default value: 1234 -H, --host=TCP_HOST Host name Default value: localhost TCP_PORT TCP port value between 0 and 65535. Use port 0 to dynamically assign a port Can use base prefix (0x,0o,0b). TCP_HOST TCP host name or IP. DIR Directory More info: \u0026lt;https://d4c7.github.io/zig-zagueando/\u0026gt;. ","permalink":"https://d4c7.github.io/zig-zagueando/posts/un-analizador-de-linea-de-comandos-en-zig-1/","summary":"¬°Hola a todos! üëã Hoy vamos a hablar de un tema muy interesante: c√≥mo analizar los argumentos de la l√≠nea de comandos. ¬°Prep√°rate para una profunda inmersi√≥n! üåäüèä‚Äç‚ôÇÔ∏è\nIntroducci√≥n a los Argumentos de la L√≠nea de Comandos üìù Los argumentos de la l√≠nea de comandos son una forma com√∫n de especificar opciones para programas ejecutables. Son especialmente √∫tiles para interactuar con tu programa de forma flexible y potente. En esencia, los argumentos de la l√≠nea de comandos son una lista de palabras que se pasan a un programa cuando se invoca.","title":"Un analizador de l√≠nea de comandos en Zig üîß (Parte I)"},{"content":"¬°Hola a todos! üôå ¬°Vamos a sumergirnos en uno de los conceptos m√°s apasionantes y poderosos de Zig: el comptime! Esta caracter√≠stica, si no has o√≠do hablar de ella, puede cambiar completamente tu perspectiva sobre c√≥mo escribir c√≥digo. üòÆ\n¬øQu√© es comptime? El t√©rmino comptime viene de \u0026ldquo;Compile Time\u0026rdquo; que, traducido al espa√±ol, ser√≠a \u0026ldquo;Tiempo de Compilaci√≥n\u0026rdquo;. En realidad has usado esa funcionalidad muchas veces, en su forma m√°s b√°sica, cada vez que utilizas una constante. En Zig, puedes decidir qu√© parte de tu c√≥digo se ejecutar√° en tiempo de compilaci√≥n y cu√°l en tiempo de ejecuci√≥n. üïì\nPrincipales ventajas de comptime Quiz√°s te est√©s preguntando, ¬øpor qu√© querr√≠amos hacer c√°lculos en tiempo de compilaci√≥n?\nFlexibilidad: Gracias a comptime, puedes generar c√≥digo en tiempo de compilaci√≥n de forma din√°mica. Esto significa que puedes decidir c√≥mo se comportar√° tu programa en funci√≥n de las condiciones existentes durante la compilaci√≥n. üòè\nEficiencia: Al mover ciertas operaciones al tiempo de compilaci√≥n, puedes mejorar significativamente la eficiencia de tu c√≥digo en tiempo de ejecuci√≥n. En lugar de calcular algo cada vez que se ejecuta tu programa, lo calculas una vez durante la compilaci√≥n y ya est√°. Es como preparar toda la comida de antemano para que, cuando lleguen los invitados, ¬°solo tengas que encender el fuego! üç≥‚è≤Ô∏è\nSeguridad: comptime puede ayudarte a detectar errores en tiempo de compilaci√≥n en lugar de en tiempo de ejecuci√≥n. Cuanto antes detectes los errores, m√°s segura ser√° tu aplicaci√≥n. üí™\nAbstracci√≥n sin costo: A diferencia de otros lenguajes que pagan un precio por abstracciones de alto nivel (con rendimiento m√°s lento o m√°s memoria usada), Zig permite abstracciones sin costos adicionales, gracias al poder de comptime.üéâ\nEjemplo b√°sico de uso de comptime En su forma m√°s b√°sica comptime es la forma en la que una variable se calcula en tiempo de compilaci√≥n para convertirse en una constante en tiempo de ejecuci√≥n. Aqu√≠ hay un peque√±o fragmento de c√≥digo para que te hagas una idea de c√≥mo se utiliza comptime.\n‚ö†Ô∏è ¬°Atenci√≥n, programador! Este post utiliza la versi√≥n 0.11.0-dev.3971 de Zig\nfn suma() u64 { var r: u64 = 0; for (1..100) |i| { r += i; } return r; } pub fn main() void { var s = comptime suma(); std.debug.print(\u0026#34;{}\u0026#34;, .{s}); sumaB(); } Cuando compiles este c√≥digo, ver√°s que suma se calcula en tiempo de compilaci√≥n y su resultado es simplemente una constante. En tiempo de ejecuci√≥n, este bloque comptime no tiene ning√∫n efecto.\nexample.main: push rbp mov rbp, rsp sub rsp, 16 mov qword ptr [rbp - 8], 4950 call debug.print__anon_3471 add rsp, 16 pop rbp ret Explicaci√≥n del c√≥digo Este c√≥digo es esamblador de arquitectura x86-64 (o AMD64):\npush rbp: Guarda el valor actual del puntero base del marco (frame base pointer) en la pila. Esto se hace generalmente al inicio de una funci√≥n para preservar el valor actual de rbp para poder restaurarlo m√°s tarde.\nmov rbp, rsp: Establece el puntero base del marco al valor actual del puntero de la pila (stack pointer). Esto se hace para que la funci√≥n tenga un punto de referencia fijo para acceder a las variables locales y los argumentos.\nsub rsp, 16: Reserva 16 bytes en la pila para las variables locales de esta funci√≥n, moviendo el puntero de la pila hacia abajo (en la mayor√≠a de las arquitecturas, la pila crece hacia abajo en la memoria).\nmov qword ptr [rbp - 8], 4950: Guarda el valor 4950 en la ubicaci√≥n de la pila 8 bytes por debajo del puntero base del marco. Probablemente esto est√° inicializando una variable local.\ncall debug.print__anon_3471: Llama a la funci√≥n debug.print__anon_3471. Esta funci√≥n pinta el valor de la variable local que acabamos de inicializar.\nadd rsp, 16: Restablece el puntero de la pila a su posici√≥n antes de que reserv√°ramos espacio para las variables locales. Esto efectivamente \u0026ldquo;libera\u0026rdquo; ese espacio de la pila.\npop rbp: Restaura el puntero base del marco a su valor antes de la llamada a la funci√≥n, esencialmente limpiando despu√©s de que la funci√≥n haya terminado.\nret: Retorna de la funci√≥n, saltando de vuelta a la direcci√≥n de retorno almacenada en la pila por la instrucci√≥n call que llam√≥ a esta funci√≥n.\nOtra forma de asignar un c√°lculo en comptime a una variable o constate es usando break :etiqueta valor en un bloque:\nvar s = comptime e: { var r: u64 = 0; for (1..100) |i| { r += i; } break :e r; }; ¬øPero que pasar√≠a si nos encontramos un bucle demasiado largo en tiempo de compilaci√≥n? Comptime tiene un limitador de la cantidad de ramificaciones que se pueden evaluar en tiempo de compilaci√≥n, lo cual es √∫til para prevenir bucles infinitos y otros problemas que pueden consumir una cantidad excesiva de recursos durante la compilaci√≥n. Se puede cambiar el l√≠mite con la funci√≥n @setEvalBranchQuota(), que por defecto es 1000.\nConviene recordarlo si nos encontramos con un error similar a este compilando:\nerror: evaluation exceeded 1000 backwards branches note: use @setEvalBranchQuota() to raise the branch limit from 1000 Comparaci√≥n con tiempo de ejecuci√≥n Entonces, ¬øc√≥mo se compara comptime con los c√°lculos en tiempo de ejecuci√≥n tradicionales? Cuando un programa Zig se est√° ejecutando, a menudo hay decisiones que tomar, como elegir qu√© ramas de c√≥digo ejecutar. Normalmente, esto ocurre en tiempo de ejecuci√≥n, pero con comptime, estas decisiones se pueden tomar en tiempo de compilaci√≥n. Es como resolver la mayor parte del rompecabezas antes de que empiece a correr el reloj. ‚è≥üß©\nAplicaciones pr√°cticas de comptime De acuerdo, la teor√≠a es buena, ¬°pero veamos comptime en acci√≥n! Te guiar√© a trav√©s de algunos ejemplos pr√°cticos donde comptime puede brillar, como cuando trabajas con metaprogramaci√≥n o programaci√≥n gen√©rica. ¬°Aqu√≠ es donde comptime pasa de ser simplemente \u0026lsquo;genial\u0026rsquo; a \u0026lsquo;absolutamente fant√°stico\u0026rsquo;! üåüüîß\nQu√© es @compileLog En Zig, @compileLog es una funci√≥n incorporada que te permite registrar mensajes durante el tiempo de compilaci√≥n. Es una herramienta maravillosa para la depuraci√≥n o para entender lo que est√° sucediendo en tiempo de compilaci√≥n. Aqu√≠ tienes un ejemplo r√°pido:\ncomptime { const a = 5; @compileLog(\u0026#34;Valor de a en tiempo de compilaci√≥n: \u0026#34;, a); } En el c√≥digo anterior, @compileLog imprimir√° el mensaje \u0026ldquo;Valor de a en tiempo de compilaci√≥n: 5\u0026rdquo; durante el proceso de compilaci√≥n. ¬°Esto puede ser muy √∫til cuando est√°s lidiando con expresiones o funciones comptime complejas! ü§îüí≠\nHay que hace notar que, a d√≠a de hoy, la compilaci√≥n fallar√° si se ha ejecutado cualquier @compileLog. La raz√≥n es evitar que las librer√≠as polucionen de mensajes la compilaci√≥n de un programa.\nQu√© es @compileError @compileError es otra funci√≥n incorporada en Zig que se utiliza para lanzar un error en tiempo de compilaci√≥n. Esto es s√∫per √∫til para asegurar ciertas condiciones durante el tiempo de compilaci√≥n y detener la compilaci√≥n si no se cumplen. As√≠ es c√≥mo puedes usarlo:\ncomptime { if (!std.builtin.target.isWasm()) { @compileError(\u0026#34;WasmPageAllocator is only available for wasm32 arch\u0026#34;); } } En este ejemplo, si la arquitectura en la se est√° intentando compilar el programa no es la adecuada se lanzar√° un error de compilaci√≥n con @compileError üí•üõë\nComptime para metaprogramaci√≥n La metaprogramaci√≥n se refiere a la capacidad de un programa para tratar su c√≥digo como datos y manipularlo. En Zig, comptime proporciona una forma poderosa de lograr la metaprogramaci√≥n. Por ejemplo, puedes generar funciones especializadas para diferentes tipos:\nfn createAdder(comptime T: type) type { return struct { fn add(a: T, b: T) T { return a + b; } }; } const IntAdder = createAdder(i32); const FloatAdder = createAdder(f32); var i = IntAdder.add(10, 20); var f = FloatAdder.add(1.0, 2.0); En el c√≥digo anterior, estamos generando dos estructuras en tiempo de compilaci√≥n: IntAdder y FloatAdder. Cada una tiene una funci√≥n add, pero trabajan con tipos diferentes (i32 y f32). ¬°Esto es solo la punta del iceberg cuando se trata de metaprogramaci√≥n con comptime! üß†üîÆ\nPor ejemplo, podemos crear estructuras completas en tiempo de compilaci√≥n:\nfn makeType(comptime n: usize) type { var fields: [n]std.builtin.Type.StructField = undefined; inline for (0..n) |v| { const default_value: u32 = v; fields[v] = .{ .name = std.fmt.comptimePrint(\u0026#34;field{}\u0026#34;, .{v}), .type = @TypeOf(default_value), .default_value = @ptrCast(*const anyopaque, \u0026amp;default_value), .is_comptime = false, .alignment = @alignOf(@TypeOf(default_value)), }; } return @Type(.{ .Struct = .{ .layout = .Auto, .fields = fields[0..], .decls = \u0026amp;.{}, .is_tuple = false, } }); } const T2 = comptime makeType(2); std.debug.print(\u0026#34;{any}\\n\u0026#34;, .{T2{}}); const T3 = comptime makeType(3); std.debug.print(\u0026#34;{any}\\n\u0026#34;, .{T3{}}); sample.makeType(2){ .field0 = 0, .field1 = 1 } sample.makeType(3){ .field0 = 0, .field1 = 1, .field2 = 2 } Detalles importantes en este c√≥digo:\nLa matriz fields tiene un tama√±o fijo determinado en tiempo de compilaci√≥n.\nEl bucle inline for itera sobre el rango 0..n. Es por tanto un bucle que se desenrrolla. ¬øCrees que es obligatorio este desenrollado? ¬øEn necesario?\nComptime y asignaci√≥n de memoria Lo ideal ser√≠a poder utilizar todas las estructuras de datos disponibles en Zig para poder ejecutar c√°lculos en tiempo de compilaci√≥n. Aunque de momento no existe en la librer√≠a est√°ndar un asignador de memoria (allocator) de Zig en para tiempo de compilaci√≥n, podemos implementar el nuestro propio con facilidad. As√≠, con un poco de cuidado, podremos usar en comptime, de forma auxilia,r estructuras como std.ArrayList:\nfn makeSlice(allocator: std.mem.Allocator) ![]u8 { var list = std.ArrayList(u8).init(allocator); defer list.deinit(); try list.append(1); try list.append(2); return try list.toOwnedSlice(); } const array = comptime e: { var buffer: [1024]u8 = undefined; var cfba = ComptimeFixedBufferAllocator.init(\u0026amp;buffer); const v = makeSlice(cfba.allocator()) catch { @compileError(\u0026#34;allocation error, increase fixed buffer size\u0026#34;); }; break :e v[0..].*; }; std.debug.print(\u0026#34;{any}\\n\u0026#34;, .{array}); ‚ö†Ô∏è ¬°Atenci√≥n, programador! Ten en cuenta que siempre debes transformar los slices en matrices constantes para evitar incrustar todo el buffer de memoria del allocator en el programa compilado final, f√≠jate en break :e v[0..].*;. Esto es importante.\nVer c√≥digo de ejemplo de un allocator para comptime Es b√°sicamente una copia de std.heap.FixedBufferAllocator. Por cierto, ¬øpor qu√© crees que no podemos usarlo en comptime?:\npub const ComptimeFixedBufferAllocator = struct { end_index: usize, buffer: []u8, pub fn init(buffer: []u8) ComptimeFixedBufferAllocator { return ComptimeFixedBufferAllocator{ .buffer = buffer, .end_index = 0, }; } pub fn allocator(self: *ComptimeFixedBufferAllocator) std.mem.Allocator { return .{ .ptr = self, .vtable = \u0026amp;.{ .alloc = alloc, .resize = resize, .free = free, }, }; } pub fn isLastAllocation(self: *ComptimeFixedBufferAllocator, buf: []u8) bool { return buf.ptr + buf.len == self.buffer.ptr + self.end_index; } fn alloc(ctx: *anyopaque, n: usize, log2_ptr_align: u8, ra: usize) ?[*]u8 { const self = @ptrCast(*ComptimeFixedBufferAllocator, @alignCast(@alignOf(ComptimeFixedBufferAllocator), ctx)); _ = ra; const ptr_align = @as(usize, 1) \u0026lt;\u0026lt; @intCast(std.mem.Allocator.Log2Align, log2_ptr_align); const adjust_off = std.mem.alignPointerOffset(self.buffer.ptr + self.end_index, ptr_align) orelse return null; const adjusted_index = self.end_index + adjust_off; const new_end_index = adjusted_index + n; if (new_end_index \u0026gt; self.buffer.len) return null; self.end_index = new_end_index; return self.buffer.ptr + adjusted_index; } fn resize( ctx: *anyopaque, buf: []u8, log2_buf_align: u8, new_size: usize, return_address: usize, ) bool { const self = @ptrCast(*ComptimeFixedBufferAllocator, @alignCast(@alignOf(ComptimeFixedBufferAllocator), ctx)); _ = log2_buf_align; _ = return_address; if (!self.isLastAllocation(buf)) { if (new_size \u0026gt; buf.len) return false; return true; } if (new_size \u0026lt;= buf.len) { const sub = buf.len - new_size; self.end_index -= sub; return true; } const add = new_size - buf.len; if (add + self.end_index \u0026gt; self.buffer.len) return false; self.end_index += add; return true; } fn free( ctx: *anyopaque, buf: []u8, log2_buf_align: u8, return_address: usize, ) void { const self = @ptrCast(*ComptimeFixedBufferAllocator, @alignCast(@alignOf(ComptimeFixedBufferAllocator), ctx)); _ = log2_buf_align; _ = return_address; if (self.isLastAllocation(buf)) { self.end_index -= buf.len; } } pub fn reset(self: *ComptimeFixedBufferAllocator) void { self.end_index = 0; } }; Recuerda que aunque comptime nos permite realizar algunos trucos poderosos, no es una soluci√≥n milagrosa. Es simplemente otra herramienta en nuestro kit de herramientas Zig que, cuando se usa adecuadamente, puede conducir a un c√≥digo m√°s limpio, eficiente y robusto. ¬°Pero como siempre, con un gran poder viene una gran responsabilidad! As√≠ que usemos comptime sabiamente\u0026hellip;\nLimitaciones de comptime Ô∏èüï∏Ô∏è Hay algunos posibles problemas al usar comptime de los que debes estar al tanto üòÖ. Los principales son:\nSin operaciones de I/O: Durante el tiempo de compilaci√≥n, no puedes realizar ninguna operaci√≥n de entrada/salida. As√≠ es, no puedes leer archivos, escribir en la consola, comunicarte a trav√©s de la red, ¬°nada! Recuerda, comptime opera en una m√°quina abstracta idealizada sin acceso al mundo exterior. üåêüîí\nSin acceso a variables de entorno: De manera similar, comptime no tiene acceso a las variables de entorno en tiempo de ejecuci√≥n. Esto incluye cosas como la hora del sistema, el identificador del proceso o las variables de entorno espec√≠ficas del usuario. ¬°Todo se trata del c√≥digo, amigos! üñ•Ô∏èüö´\nAsignaci√≥n de memoria: Hablamos antes de c√≥mo comptime gestiona la memoria y la falta de un allocator para comptime. Es importante recordar que comptime y el tiempo de ejecuci√≥n son dos dominios diferentes. üßô‚Äç‚ôÇÔ∏èüè∞\n¬°Y ya est√°, amigos!. Un profundo viaje al mundo m√°gico de comptime en Zig. Espero que hayas disfrutado nuestro recorrido y que ahora est√©s tan entusiasmado con comptime como yo. Recuerda, el aprendizaje es un proceso continuo, as√≠ que nunca dejes de explorar y experimentar con Zig. ¬°Sigue codificando con pasi√≥n y creatividad! üöÄüíª\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/zig-comptime/","summary":"¬°Hola a todos! üôå ¬°Vamos a sumergirnos en uno de los conceptos m√°s apasionantes y poderosos de Zig: el comptime! Esta caracter√≠stica, si no has o√≠do hablar de ella, puede cambiar completamente tu perspectiva sobre c√≥mo escribir c√≥digo. üòÆ\n¬øQu√© es comptime? El t√©rmino comptime viene de \u0026ldquo;Compile Time\u0026rdquo; que, traducido al espa√±ol, ser√≠a \u0026ldquo;Tiempo de Compilaci√≥n\u0026rdquo;. En realidad has usado esa funcionalidad muchas veces, en su forma m√°s b√°sica, cada vez que utilizas una constante.","title":"Zig comptime"},{"content":"¬°Hola, entusiastas de Zig! Hoy vamos a explorar un emocionante campo donde Zig realmente brilla: WebAssembly (Wasm). Prep√°rate para desbloquear el poder de Zig en el navegador! üåêüí™\n¬øQu√© es WebAssembly? üßê WebAssembly es un formato de instrucci√≥n binaria dise√±ado como un objetivo portable para la compilaci√≥n de lenguajes de alto nivel como C, C++, Rust, y por supuesto, Zig. Nos permite ejecutar c√≥digo en la web a una velocidad cercana a la nativa, abriendo la web a un nuevo rango de aplicaciones.\n¬øPor qu√© Zig con WebAssembly? ü§î La simplicidad, eficiencia y robustez de Zig lo convierten en una excelente elecci√≥n para el desarrollo de WebAssembly. La capacidad de Zig para compilar cruzadamente sin problemas es una enorme ventaja, y su fuerte enfoque en la seguridad es perfecto para el entorno protegido de la web.\nEmpezando con Zig y WebAssembly üöÄ Vamos a crear un simple programa Zig y compilarlo a WebAssembly.\nComienza escribiendo un simple programa Zig. Abre tu editor de c√≥digo y crea un nuevo archivo llamado hello.zig: ‚ö†Ô∏è ¬°Atenci√≥n, programador! Este post utiliza la versi√≥n 0.11.0-dev.3971 de Zig\nextern fn print(a: i32) void; export fn add(a: i32, b: i32) i32 { print(1234); return a + b; } Este c√≥digo establece una interfaz entre Zig y JavaScript. La declaraci√≥n extern fn print(a: i32) void; permite a Zig usar la funci√≥n print de JavaScript, y export fn add(a: i32, b: i32) i32 { ... } proporciona una funci√≥n que puede ser llamada desde JavaScript.\nPara compilar este c√≥digo Zig a WebAssembly, a√±ade un archivo build.zig const std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.build.Builder) void { const target = std.zig.CrossTarget{ .cpu_arch = .wasm32, .os_tag = .freestanding, .abi = .musl, }; const optimize = b.standardOptimizeOption(.{ .preferred_optimize_mode = .ReleaseFast }); const lib = b.addSharedLibrary(.{ .name = \u0026#34;hello\u0026#34;, .root_source_file = .{ .path = \u0026#34;./hello.zig\u0026#34; }, .target = target, .optimize = optimize, }); lib.rdynamic = true; b.installArtifact(lib); } Vamos a verlo con detalle:\nconst std = @import(\u0026quot;std\u0026quot;);\nAqu√≠ estamos importando la biblioteca est√°ndar de Zig (std). Esto nos da acceso a todas las funciones y utilidades proporcionadas por la biblioteca est√°ndar. üìöüîç\npub fn build(b: *std.build.Builder) void {\nEn esta l√≠nea, definimos la funci√≥n principal build para nuestro script de compilaci√≥n, que recibe un puntero a una instancia de std.build.Builder. Este es nuestro gu√≠a para la aventura de la construcci√≥n de c√≥digo. üèóÔ∏èüó∫Ô∏è\nconst target = std.zig.CrossTarget{...};\nAqu√≠ estamos creando un objetivo de compilaci√≥n cruzada para WebAssembly con el tag del sistema operativo freestanding y la interfaz binaria de aplicaci√≥n musl. Esta es la maleta que preparamos para nuestro viaje a WebAssembly Land. üõÑüéØ\nconst optimize = b.standardOptimizeOption(...);\nAqu√≠ definimos las opciones de optimizaci√≥n. Estamos eligiendo la opci√≥n de optimizaci√≥n ReleaseFast, que es como decir \u0026ldquo;¬°Vamos a correr como el viento, pero sin tropezar!\u0026rdquo; üèÉ‚Äç‚ôÇÔ∏èüí®\nconst lib = b.addSharedLibrary(...);\nEn este paso, le decimos a nuestro gu√≠a (el constructor b) que queremos construir una biblioteca compartida llamada hello a partir del archivo de origen hello.zig, con las opciones de objetivo y optimizaci√≥n que definimos anteriormente. Es como pedirle a nuestro gu√≠a que prepare los planes para construir un puente a WebAssembly Land. üåâüõ†Ô∏è\nlib.rdynamic = true;\nLa opci√≥n rdynamic es absolutamente necesaria en Zig 0.11.0, ya que el linker de wasm integrado en Zig no exporta los s√≠mbolos definidos. La opci√≥n rdynamic sirve para enlazar dinamicamente librer√≠as y es particularmente √∫til cuando quieres exportar s√≠mbolos desde un ejecutable. El uso de esta opci√≥n en el contexto de WebAssembly es una soluci√≥n (workaround) a este problema.\nb.installArtifact(lib);\nFinalmente, le decimos a nuestro gu√≠a que instale la biblioteca que acabamos de construir. Esto coloca nuestra hermosa biblioteca hello en el lugar correcto para que otros puedan usarla. Es como colocar nuestro puente reci√©n construido en el mapa para que todos puedan encontrarlo. üó∫Ô∏èüåâ\nPara construir el proyecto teclea el siguiente comando:\nzig build Tenemos nuestro m√≥dulo listo, ahora vamos por el HTML y Javascript. Creamos un archivo index.html: \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;es\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Zig: ¬°Hola WASM!\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;Zig: ¬°Hola WASM!\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;(¬°Abre la consola!)\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script src=\u0026#34;loader.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; Creamos un script de carga para cargar y ejecutar nuestro m√≥dulo WebAssembly. Creamos un nuevo archivo en el mismo directorio llamado loader.js: WebAssembly.instantiateStreaming(fetch(\u0026#39;zig-out/lib/hello.wasm\u0026#39;), { env: { print: function (x) { console.log(\u0026#34;Llamada desde zig:\u0026#34;, x); } } }).then(result =\u0026gt; { const add = result.instance.exports.add; console.log(\u0026#34;Llamada a Zig:\u0026#34;, add(3, 5)); }); Este c√≥digo muestra c√≥mo se puede cargar y ejecutar un m√≥dulo WebAssembly en un entorno de navegador. Para ello, se prepara una solicitud HTTP GET al archivo .wasm que se pasa a WebAssembly.instantiateStreaming para descargar, compilar y ejecutar el m√≥dulo.\nEl objeto de importaci√≥n que se pasa a WebAssembly.instantiateStreaming representa el entorno del host. En este caso, proporcionamos una funci√≥n de impresi√≥n que se puede llamar desde el m√≥dulo WebAssembly. Una vez que el m√≥dulo se ha instanciado correctamente, podemos acceder a las funciones exportadas y llamarlas como cualquier otra funci√≥n de JavaScript.\nInicia cualquier servidor HTTP Debido a las pol√≠ticas de CORS en la mayor√≠a de los navegadores, es necesario servir nuestro m√≥dulo WebAssembly a trav√©s de un servidor HTTP. Puedes hacerlo f√°cilmente con Python ejecutando el comando:\n$ python -m SimpleHTTPServer 8001 Navega a http://localhost:8001 en tu navegador, y estar√°s listo para ver el funcionamiento de tu programa.\n¬°Y eso es todo! Acabas de escribir tu primer programa Zig para WebAssembly. üéâ\nQuiero m√°s üåü Atentos a nuestros pr√≥ximos posts, donde iremos un paso m√°s all√° y construiremos juntos y poco a poco un cl√°sico: ¬°El juego ese de bloques que caen de arriba! No solo ser√° una oportunidad para divertirnos mientras programamos, sino tambi√©n una forma efectiva de aprender y profundizar en nuestros conocimientos sobre WebAssembly, Zig, juegos, IA, algoritmos, estructuras de datos, usabilidad y muchos otros.\n¬°Pru√©balo un poco para ir abriendo el apetito!\nEspero que esta publicaci√≥n te haya proporcionado una s√≥lida introducci√≥n a WebAssembly y Zig. ¬°Nos vemos en la pr√≥xima!\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/webassembly-y-zig-comenzando/","summary":"¬°Hola, entusiastas de Zig! Hoy vamos a explorar un emocionante campo donde Zig realmente brilla: WebAssembly (Wasm). Prep√°rate para desbloquear el poder de Zig en el navegador! üåêüí™\n¬øQu√© es WebAssembly? üßê WebAssembly es un formato de instrucci√≥n binaria dise√±ado como un objetivo portable para la compilaci√≥n de lenguajes de alto nivel como C, C++, Rust, y por supuesto, Zig. Nos permite ejecutar c√≥digo en la web a una velocidad cercana a la nativa, abriendo la web a un nuevo rango de aplicaciones.","title":"WebAssembly y Zig: Comenzando üï∏Ô∏èüöÄ"},{"content":"¬°Hola, entusiastas de Zig! üëã En nuestra publicaci√≥n anterior, dimos nuestros primeros pasos en el mundo de Zig. Hoy, vamos a adentrarnos en el coraz√≥n de la gesti√≥n de proyectos de Zig: el sistema de construcci√≥n de Zig. ¬°Empecemos! üéâ\n¬øQu√© es el sistema de construcci√≥n de Zig? ü§î El sistema de construcci√≥n de Zig es una herramienta poderosa e incorporada que te ayuda a gestionar, compilar, probar y enlazar tus proyectos. Simplifica procesos de construcci√≥n complejos y proporciona una compilaci√≥n cruzada sin interrupciones, permiti√©ndote apuntar a diferentes plataformas con facilidad.\nEmpezando con build.zig üöÄ Para aprovechar el sistema de construcci√≥n de Zig, necesitas crear un archivo build.zig en el directorio ra√≠z de tu proyecto.\nEl conjunto de herramientas de Zig (toolchain) llama a la funci√≥n build(b: *std.Build) void de build.zig. El par√°metro bse utiliza para configurar y definir el proceso de construcci√≥n mediante pasos o instrucciones que no formen ciclos o bucles.\nPor ejemplo, podemos crear nuestro propio paso my-step:\n‚ö†Ô∏è ¬°Atenci√≥n, programador! Este post utiliza la versi√≥n 0.11.0-dev.3971 de Zig\nconst std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.build.Builder) void { const my_step = b.step(\u0026#34;my-step\u0026#34;, \u0026#34;Este paso es mi paso\u0026#34;); _ = my_step; } Este paso aparecer√° en la ayuda si ejecutamos zig build --help, y aunque no hace nada, hace mucha ilusi√≥n.\n$ zig build --help Usage: zig build [steps] [options] Steps: install (default) Copy build artifacts to prefix path uninstall Remove build artifacts from prefix path my-step Este paso es mi paso [...] Project-Specific Options: (none) [...] Tambi√©n podemos observar en la ayuda una secci√≥n Project-Specific Options, que por ahora aparece vac√≠a.\nA√±adiendo el primer paso üë£ Zig viene equipado con algunos pasos listos para usar. Uno de los m√°s interesantes es addExecutable, que permite compilar un ejecutable o librer√≠a.\nSi a√±adimos este main.zig al directorio:\nconst std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { const stdout = std.io.getStdOut().writer(); try stdout.print(\u0026#34;Hola otra vez\\n\u0026#34;, .{}); } Y definimos build.zig como:\nconst std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.Build) void { const target = b.standardTargetOptions(.{}); const optimize = b.standardOptimizeOption(.{}); const exe = b.addExecutable(.{ .name = \u0026#34;my-executable\u0026#34;, .root_source_file = .{ .path = \u0026#34;main.zig\u0026#34; }, .target = target, .optimize = optimize, }); b.installArtifact(exe); } Cuando ejecutemos el comando zig build se compilar√° nuestro ejecutable. Estas son las l√≠neas principales:\nconst target = b.standardTargetOptions(.{}): Define las opciones de destino que estar√°n disponibles y cual ser√° la de defecto, lo que permite al usuario seleccionar para qu√© plataforma se va a construir el c√≥digo.\nconst optimize = b.standardOptimizeOption(.{}): Define las opciones de optimizaci√≥n est√°ndar, lo que permite al usuario seleccionar el nivel de optimizaci√≥n para la compilaci√≥n.\nconst exe = b.addExecutable(.): A√±ade un ejecutable al proceso de construcci√≥n. Los par√°metros definen c√≥mo se construir√° el ejecutable, incluyendo el archivo fuente principal, las opciones de destino y las opciones de optimizaci√≥n.\nb.installArtifact(exe): Esta l√≠nea declara que el ejecutable creado en el paso anterior debe ser instalado en la ubicaci√≥n est√°ndar cuando se realiza el paso de instalaci√≥n.\nSi volvemos a ejecutar zig build --help observaremos como ahora la secci√≥n Project-Specific Options muestra opciones para establecer la plataforma, caracter√≠sticas de la cpu y la optimizaci√≥n desde l√≠nea de comandos.\nProject-Specific Options: -Dtarget=[string] The CPU architecture, OS, and ABI to build for -Dcpu=[string] Target CPU features to add or subtract -Doptimize=[enum] Prioritize performance, safety, or binary size (-O flag) Supported Values: Debug ReleaseSafe ReleaseFast ReleaseSmall Al lanzar zig build se generar√°n dos directorios importantes:\nzig-cache: Este directorio contiene artefactos de construcci√≥n intermedios, como archivos de objeto, y es utilizado por el sistema de construcci√≥n de Zig para almacenar en cach√© los resultados de la construcci√≥n y acelerar las compilaciones posteriores. zig-out: Este directorio almacena la salida final de tu proceso de construcci√≥n, incluyendo ejecutables, bibliotecas y otros binarios. Compilaci√≥n cruzada hecha f√°cil üåâ Una de las caracter√≠sticas m√°s poderosas del sistema de construcci√≥n de Zig es su capacidad para compilar de forma cruzada tus proyectos. Para ello simplemente proporciona la opci√≥n --target cuando ejecutes zig build:\nzig build -Dtarget=aarch64-linux-gnu Este comando compila tu proyecto para la plataforma objetivo especificada, manejando todas las complejidades por ti. üéâ\n$ file zig-out/bin/executable zig-out/bin/executable: ELF 64-bit LSB executable, ARM aarch64, version 1 (SYSV), statically linked, with debug_info, not stripped A√±adiendo m√°s pasos üë£üë£ Ahora que sabemos como funciona podemos a√±adir otros dos pasos, uno para ejecutar el programa y otro para lanzar los tests:\nconst std = @import(\u0026#34;std\u0026#34;); pub fn build(b: *std.Build) void { // compilaci√≥n const target = b.standardTargetOptions(.{}); const optimize = b.standardOptimizeOption(.{}); const exe = b.addExecutable(.{ .name = \u0026#34;executable\u0026#34;, .root_source_file = .{ .path = \u0026#34;main.zig\u0026#34; }, .target = target, .optimize = optimize, }); b.installArtifact(exe); // ejecuci√≥n const run_cmd = b.addRunArtifact(exe); if (b.args) |args| { run_cmd.addArgs(args); } run_cmd.step.dependOn(b.getInstallStep()); const run_step = b.step(\u0026#34;run\u0026#34;, \u0026#34;Run the app\u0026#34;); run_step.dependOn(\u0026amp;run_cmd.step); // tests const unit_tests = b.addTest(.{ .root_source_file = .{ .path = \u0026#34;main_test.zig\u0026#34; }, .target = target, .optimize = optimize, }); const run_unit_tests = b.addRunArtifact(unit_tests); const test_step = b.step(\u0026#34;test\u0026#34;, \u0026#34;Run unit tests\u0026#34;); test_step.dependOn(\u0026amp;run_unit_tests.step); } En este c√≥digo podemos ver\nEl bloque if (b.args) |args| {...}: A√±ade cualquier argumento pasado al comando de ejecuci√≥n.\nconst run_step = b.step(\u0026quot;run\u0026quot;, \u0026quot;Run the app\u0026quot;): Crea un paso de construcci√≥n que ejecuta el comando de ejecuci√≥n.\nconst unit_tests = b.addTest(.) y const run_unit_tests = b.addRunArtifact(unit_tests): Crea un paso para las pruebas unitarias. Este paso construye el ejecutable de prueba pero no lo ejecuta.\nconst test_step = b.step(\u0026quot;test\u0026quot;, \u0026quot;Run unit tests\u0026quot;): Este paso ejecuta las pruebas unitarias.\nPara a√±adir los test a√±adimos el archivo main_test.zig:\nconst std = @import(\u0026#34;std\u0026#34;); test \u0026#34;simple test\u0026#34; { try std.testing.expect(addOne(41) == 42); } fn addOne(number: i32) i32 { return number + 1; } Para crear un caso de prueba en Zig, usa la palabra clave test, seguida de un nombre de prueba y un bloque de c√≥digo.\nPara lanzar los test usamos el comando zig build test. Si todo va bien no deber√≠amos ver ning√∫n error, el comando es realmente muy silencioso.\n¬øSe puede m√°s f√°cil? üòÖ Crear un archivo build.zig puede ser un poco tedioso, m√°s aun cuando todav√≠a no dominamos el lenguaje. Pero no tienes por qu√© empezar desde cero. El comando zig init-exe te generar√° las carpetas y archivos necesarios para compilar, ejecutar y pasar los test de un proyecto de b√°sico de ejemplo en el directorio donde te encuentres.\n¬øQu√© sigue? üåü ¬°Eso es todo! Ahora tienes un s√≥lido entendimiento del sistema de construcci√≥n de Zig y puedes usarlo para gestionar, construir y compilar de forma cruzada tus proyectos con facilidad. üí°\n¬°Feliz codificaci√≥n y nos vemos en la pr√≥xima publicaci√≥n! üë©‚Äçüíªüë®‚ÄçüíªüöÄ\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/una-gu%C3%ADa-del-sistema-de-construcci%C3%B3n-en-zig/","summary":"¬°Hola, entusiastas de Zig! üëã En nuestra publicaci√≥n anterior, dimos nuestros primeros pasos en el mundo de Zig. Hoy, vamos a adentrarnos en el coraz√≥n de la gesti√≥n de proyectos de Zig: el sistema de construcci√≥n de Zig. ¬°Empecemos! üéâ\n¬øQu√© es el sistema de construcci√≥n de Zig? ü§î El sistema de construcci√≥n de Zig es una herramienta poderosa e incorporada que te ayuda a gestionar, compilar, probar y enlazar tus proyectos.","title":"Una gu√≠a del sistema de construcci√≥n de Zig üèóÔ∏è"},{"content":"¬°Saludos, entusiastas de Zig! üëã Es el momento de configurar un entorno de desarrollo c√≥modo para mejorar tu experiencia de programaci√≥n en Zig. En esta publicaci√≥n, te guiar√© para configurar Visual Studio Code (VS Code) para el desarrollo en Zig, incluyendo edici√≥n de c√≥digo, ejecuci√≥n y depuraci√≥n. ¬°Sum√©rgete en el tema! üöÄ\nConfigurando Visual Studio Code para el desarrollo en Zig üõ†Ô∏è Para configurar VS Code para el desarrollo en Zig, sigue estos pasos:\nInstala Visual Studio Code: Si a√∫n no lo has hecho, descarga e instala Visual Studio Code para tu plataforma (Linux, Windows o macOS).\nInstala la extensi√≥n de Zig: Abre el buscador r√°pido de VS Code (Ctrl+P), pega el siguiente comando y presiona enter.\next install ziglang.vscode-zig Configura los ajustes: Para configurar los ajustes de la extensi√≥n de Zig, abre el editor de Configuraci√≥n haciendo clic en el √≠cono de engranaje en la esquina inferior izquierda de la ventana y selecciona \u0026ldquo;Configuraci√≥n\u0026rdquo;. Busca \u0026ldquo;Zig\u0026rdquo; en la barra de b√∫squeda y actualiza los ajustes seg√∫n sea necesario. Por ejemplo, es posible que desees establecer la ruta del compilador de Zig si no est√° en la ubicaci√≥n predeterminada. ¬°Listo! Ahora est√°s listo para desarrollar en Zig en VS Code. üéâ\nEjecutando y depurando c√≥digo üèÉ‚Äç‚ôÄÔ∏èüíª Para ejecutar y depurar c√≥digo Zig en VS Code, sigue estos pasos:\nCrea un nuevo archivo Zig: Abre VS Code y crea un nuevo archivo con la extensi√≥n .zig, como main.zig.\nEscribe c√≥digo Zig: Escribe un programa sencillo en Zig en tu nuevo archivo, como un programa \u0026ldquo;Hola, mundo\u0026rdquo;:\n‚ö†Ô∏è ¬°Atenci√≥n, programador! Este post utiliza la versi√≥n 0.11.0-dev.3971 de Zig\nconst std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { std.debug.print(\u0026#34;Hello, {s}!\\n\u0026#34;, .{\u0026#34;World\u0026#34;}); } Configura tasks.json: Para ejecutar tu c√≥digo Zig, necesitas crear un archivo tasks.json en la carpeta .vscode de tu espacio de trabajo. Agrega la siguiente configuraci√≥n al archivo: { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;label\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;shell\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;zig build-exe main.zig\u0026#34;, \u0026#34;group\u0026#34;: \u0026#34;build\u0026#34; } ] } Este archivo de configuraci√≥n define tareas para Visual Studio Code. Las tareas se utilizan para automatizar el proceso de construcci√≥n, prueba y despliegue de tu aplicaci√≥n. En este caso, estamos definiendo la tarea de compilaci√≥n:\n\u0026quot;label\u0026quot;: \u0026quot;build\u0026quot; - Es el nombre que se le da a la tarea. En este caso, la tarea se llama \u0026ldquo;build\u0026rdquo;. \u0026quot;type\u0026quot;: \u0026quot;shell\u0026quot; - Especifica que esta tarea se ejecutar√° en una shell o terminal. \u0026quot;command\u0026quot;: \u0026quot;zig build-exe main.zig\u0026quot; - Es el comando que se ejecutar√° cuando se inicie esta tarea. Este comando compilar√° el archivo main.zig en un ejecutable utilizando el compilador Zig. \u0026quot;group\u0026quot;: \u0026quot;build\u0026quot; - Esto agrupa la tarea en la categor√≠a \u0026ldquo;build\u0026rdquo;. Las tareas se pueden agrupar para un f√°cil acceso y gesti√≥n en Visual Studio Code. Ejecuta tu c√≥digo Zig: Presiona Ctrl+Shift+B (o Cmd+Shift+B en macOS) para ejecutar la tarea \u0026ldquo;build\u0026rdquo;, que compila tu c√≥digo Zig. Salida:\n* Executing task: zig build-exe \u0026lt;...\u0026gt;/main.zig * Terminal will be reused by tasks, press any key to close it. Depuraci√≥n: Para depurar tu c√≥digo Zig, primero debes instalar las extensiones \u0026ldquo;Native Debug\u0026rdquo; de WebFreak y \u0026ldquo;CodeLLDB\u0026rdquo; de Vadim Chugunov. Presiona ctrl-p (cmd+p en macOS) y ejecuta los siguientes comandos:\next install webfreak.debug y\next install vadimcn.vscode-lldb Una vez instaladas, crea un archivo launch.json en la carpeta .vscode de tu espacio de trabajo con la siguiente configuraci√≥n:\n{ \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Debug Zig\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;lldb\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;main\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;preLaunchTask\u0026#34;: \u0026#34;build\u0026#34; } ] } Este archivo de configuraci√≥n de lanzamiento se usa para definir c√≥mo se debe depurar un proyecto. El campo configurations tiene una lista de diferentes configuraciones de depuraci√≥n que puedes usar. Puedes cambiar entre estas configuraciones en el men√∫ desplegable de depuraci√≥n en la parte superior de VS Code. La configuraci√≥n se define as√≠:\nname: Es el nombre que aparece en el men√∫ desplegable de depuraci√≥n. En este caso, est√° configurado como \u0026ldquo;Debug Zig\u0026rdquo;, lo que indica que esta configuraci√≥n es para depurar programas escritos en Zig. type: Define el depurador que se utilizar√°. En este caso, \u0026ldquo;lldb\u0026rdquo; indica que se utilizar√° el depurador LLDB de LLVM. request: Puede ser \u0026ldquo;launch\u0026rdquo; o \u0026ldquo;attach\u0026rdquo;. \u0026ldquo;launch\u0026rdquo; inicia el programa en el depurador, mientras que \u0026ldquo;attach\u0026rdquo; se conecta a un proceso ya en ejecuci√≥n. En la configuraci√≥n el valor es \u0026ldquo;launch\u0026rdquo;, por lo que el depurador iniciar√° el programa. program: Es el nombre del programa que se va a iniciar. En esta configuraci√≥n, el valor es \u0026ldquo;main\u0026rdquo;, por lo que se espera un ejecutable llamado \u0026ldquo;main\u0026rdquo; en tu directorio de trabajo actual. args: Es una lista de argumentos que se pasar√°n al programa cuando se lance. En tu caso, esta lista est√° vac√≠a, por lo que no se pasar√°n argumentos. cwd: Especifica el directorio de trabajo actual cuando se inicia el programa. \u0026ldquo;${workspaceFolder}\u0026rdquo; es una variable que se refiere al directorio ra√≠z de tu espacio de trabajo actual en VS Code. preLaunchTask: Es el nombre de una tarea definida en tasks.json que se ejecutar√° antes de que se lance el programa. Este es solo un ejemplo de configuraci√≥n de depuraci√≥n. La configuraci√≥n exacta puede variar seg√∫n el lenguaje de programaci√≥n y el entorno de desarrollo espec√≠ficos que est√©s utilizando.\nDepura tu c√≥digo Zig: Establece puntos de interrupci√≥n en tu c√≥digo Zig haciendo clic en el margen izquierdo junto a los n√∫meros de l√≠nea. Presiona F5 para iniciar la depuraci√≥n. El depurador se detendr√° en tus puntos de interrupci√≥n, lo que te permitir√° inspeccionar variables, avanzar paso a paso en tu c√≥digo y utilizar otras funciones de depuraci√≥n. ¬°Eso es todo! Ahora has configurado Visual Studio Code para el desarrollo en Zig, incluyendo la ejecuci√≥n, asistencia y depuraci√≥n de tu c√≥digo. üéâ\n¬øQu√© m√°s? üåü Con tu flamante entorno de desarrollo Zig, est√°s listo para explorar temas avanzados de Zig y crear proyectos asombrosos. ¬°Mantente atento a m√°s publicaciones en el blog sobre conceptos avanzados de Zig!\n¬°Sigamos explorando el mundo de Zig juntos! üë©‚Äçüíªüë®‚Äçüíªüé®\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/configura-visual-studio-code-para-programar-en-zig/","summary":"¬°Saludos, entusiastas de Zig! üëã Es el momento de configurar un entorno de desarrollo c√≥modo para mejorar tu experiencia de programaci√≥n en Zig. En esta publicaci√≥n, te guiar√© para configurar Visual Studio Code (VS Code) para el desarrollo en Zig, incluyendo edici√≥n de c√≥digo, ejecuci√≥n y depuraci√≥n. ¬°Sum√©rgete en el tema! üöÄ\nConfigurando Visual Studio Code para el desarrollo en Zig üõ†Ô∏è Para configurar VS Code para el desarrollo en Zig, sigue estos pasos:","title":"Configura Visual Studio Code para programar en Zig üé®"},{"content":"¬°Hola, entusiastas de Zig! üëã En la publicaci√≥n anteriores hemos visto que Zig mola mucho. Pero antes de sumergirnos en temas m√°s avanzados, vamos a asegurarnos de tener Zig instalado y funcionando en nuestros sistemas. En esta publicaci√≥n, te guiar√© en la instalaci√≥n de Zig en Linux, Windows y macOS. ¬°Comencemos! üöÄ\nInstalando Zig en Linux üêß ‚ö†Ô∏è ¬°Atenci√≥n, programador! Este post utiliza la versi√≥n 0.11.0-dev.3971 de Zig\nPara usuarios de Linux, puedes instalar Zig utilizando los paquetes precompilados o construy√©ndolo desde el c√≥digo fuente.\nPaquetes precompilados: Descarga el paquete apropiado para tu distribuci√≥n de Linux desde la p√°gina oficial de descargas de Zig. Extrae el archivo y agrega el binario zig a tu PATH.\nConstruir desde el c√≥digo fuente: Si prefieres construir Zig desde el c√≥digo fuente, sigue estos pasos:\nInstala las dependencias necesarias: build-essential, cmake y git. Clona el repositorio de Zig: git clone https://github.com/ziglang/zig.git Cambia al directorio clonado: cd zig Crea un directorio de construcci√≥n: mkdir build \u0026amp;\u0026amp; cd build Ejecuta CMake para configurar la construcci√≥n: cmake .. Construye Zig: make Agrega el binario zig a tu PATH. Una forma alternativa es usar snap: snap install --edge zig --classic\nInstalando Zig en Windows üíª Para usuarios de Windows, puedes instalar Zig utilizando los paquetes precompilados o el administrador de paquetes Scoop.\nPaquetes precompilados: Descarga el paquete apropiado para tu sistema desde la p√°gina oficial de descargas de Zig. Extrae el archivo y agrega el binario zig a tu PATH.\nScoop: Si tienes Scoop instalado, puedes instalar Zig ejecutando: scoop install zig\nInstalando Zig en macOS üçè Para usuarios de macOS, puedes instalar Zig utilizando los paquetes precompilados, Homebrew o MacPorts.\nPaquetes precompilados: Descarga el paquete apropiado para tu sistema desde la p√°gina oficial de descargas de Zig. Extrae el archivo y agrega el binario zig a tu PATH.\nHomebrew: Si tienes Homebrew instalado, puedes instalar Zig ejecutando: brew install zig\nMacPorts: Si tienes MacPorts instalado, puedes instalar Zig ejecutando: sudo port install zig\n¬°Listo! Ahora deber√≠as tener Zig instalado en tu sistema Linux, Windows o macOS. üéâ\n¬øQu√© m√°s? üåü Con Zig instalado, est√°s listo para explorar temas m√°s avanzados y aprovechar todo el potencial de este emocionante lenguaje.\n¬°√Ånimo programador!\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/instalando-zig-en-linux-windows-y-macos/","summary":"¬°Hola, entusiastas de Zig! üëã En la publicaci√≥n anteriores hemos visto que Zig mola mucho. Pero antes de sumergirnos en temas m√°s avanzados, vamos a asegurarnos de tener Zig instalado y funcionando en nuestros sistemas. En esta publicaci√≥n, te guiar√© en la instalaci√≥n de Zig en Linux, Windows y macOS. ¬°Comencemos! üöÄ\nInstalando Zig en Linux üêß ‚ö†Ô∏è ¬°Atenci√≥n, programador! Este post utiliza la versi√≥n 0.11.0-dev.3971 de Zig\nPara usuarios de Linux, puedes instalar Zig utilizando los paquetes precompilados o construy√©ndolo desde el c√≥digo fuente.","title":"Instalando Zig en Linux, Windows y macOS üåç"},{"content":"¬°Bienvenido al emocionante mundo de Zig! üöÄ Si est√°s buscando un lenguaje de programaci√≥n que combine eficiencia, seguridad y un enfoque en el rendimiento, ¬°has llegado al lugar correcto!\n¬øPor qu√© Zig? üéØ Una de las primeras cosas que notar√°s al explorar Zig es su enfoque en la seguridad y la prevenci√≥n de errores. El compilador de Zig es estricto y te ayudar√° a detectar problemas en tiempo de compilaci√≥n antes de que se conviertan en pesadillas en tiempo de ejecuci√≥n. Esto no solo te brinda una mayor confianza en la calidad de tu c√≥digo, sino que tambi√©n te ense√±a buenas pr√°cticas para evitar errores comunes.\nPero Zig no se detiene solo en la seguridad. Si te apasiona la programaci√≥n de alto rendimiento y quieres escribir c√≥digo que aproveche al m√°ximo los recursos del sistema, Zig es el lenguaje adecuado para ti. Su sintaxis limpia y elegante te permite escribir c√≥digo eficiente y optimizado sin sacrificar la legibilidad.\nAdem√°s, aprender Zig te brinda la oportunidad de adentrarte en el mundo de la programaci√≥n de bajo nivel. Con Zig, puedes acceder directamente a la memoria y tener un control preciso sobre los recursos del sistema. Esto es especialmente √∫til si est√°s interesado en desarrollar aplicaciones de sistemas embebidos, controladores de dispositivos o soluciones de bajo nivel.\nZig tambi√©n es una excelente opci√≥n para aquellos que est√°n aprendiendo a programar. A trav√©s de Zig, puedes adquirir una comprensi√≥n s√≥lida de los conceptos fundamentales de la programaci√≥n, como el control de flujo, las estructuras de datos y los algoritmos. Al mismo tiempo, ampliar√°s tu perspectiva sobre la programaci√≥n y desarrollar√°s habilidades valiosas para el futuro.\nNo te voy a enga√±ar: Zig a veces muerde üò¨, pero eso es bueno. Es un lenguage en plena creaci√≥n y evoluciona muy r√°pidamente con cambios incompatibles y bugs. Adem√°s su determinado enfoque en la seguridad te obliga a ser consciente de muchos aspectos que en otros lenguages simplemente se ignoran (el precio se paga despu√©s). Pero no temas programador, ¬°todo eso te har√° mas fuerte!.üí™\n¬°Hola, mundo! üëã Como en cualquier lenguaje, el primer paso es escribir un cl√°sico \u0026ldquo;Hola, mundo\u0026rdquo; en Zig para ver qu√© pinta tiene y qu√© sensaciones te produce:\n‚ö†Ô∏è ¬°Atenci√≥n, programador! Este post utiliza la versi√≥n 0.11.0-dev.3971 de Zig\n//zig version: 0.11.0-dev.3191+fd213accb const std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { const stdout = std.io.getStdOut().writer(); try stdout.print(\u0026#34;¬°Hola, mundo!\\n\u0026#34;,.{}); } Es muy poco c√≥digo pero ya se pueden observar algunas caracter√≠sticas del lenguaje Zig:\nEnfoque en la seguridad: El uso de la declaraci√≥n try para manejar errores de manera expl√≠cita demuestra la preocupaci√≥n por la seguridad y la prevenci√≥n de errores en Zig.\nSintaxis limpia y legible: La sintaxis del programa es clara y f√°cil de entender, lo que facilita la lectura y escritura de c√≥digo en Zig.\nManejo expl√≠cito de recursos: Al obtener el escritor de salida est√°ndar a trav√©s de getStdOut(), Zig enfatiza el manejo expl√≠cito de recursos, permitiendo un control m√°s preciso y seguro.\nOrientaci√≥n a bajo nivel: Zig permite acceder directamente a la memoria y proporciona un mayor control sobre los recursos del sistema, lo que es √∫til en situaciones de programaci√≥n de bajo nivel.\nEnfoque en el rendimiento: Zig est√° dise√±ado para ofrecer un rendimiento excepcional, lo que se refleja en la eficiencia del programa \u0026ldquo;Hello, World\u0026rdquo;.\nEstas cualidades son solo una peque√±a muestra de las fortalezas de Zig como lenguaje de programaci√≥n. A medida que te adentres en Zig, descubrir√°s muchas m√°s ventajas que te ayudar√°n a desarrollar software eficiente y confiable.\nOtro ejemplo, un poco m√°s completo, tiene esta pinta:\n//zig version: 0.11.0-dev.3191+fd213accb const std = @import(\u0026#34;std\u0026#34;); pub fn main() !void { // Prints to stderr (it\u0026#39;s a shortcut based on `std.io.getStdErr()`) std.debug.print(\u0026#34;All your {s} are belong to us.\\n\u0026#34;, .{\u0026#34;codebase\u0026#34;}); // stdout is for the actual output of your application, for example if you // are implementing gzip, then only the compressed bytes should be sent to // stdout, not any debugging messages. const stdout_file = std.io.getStdOut().writer(); var bw = std.io.bufferedWriter(stdout_file); const stdout = bw.writer(); try stdout.print(\u0026#34;Run `zig build test` to run the tests.\\n\u0026#34;, .{}); try bw.flush(); // don\u0026#39;t forget to flush! } test \u0026#34;simple test\u0026#34; { var list = std.ArrayList(i32).init(std.testing.allocator); defer list.deinit(); // try commenting this out and see if zig detects the memory leak! try list.append(42); try std.testing.expectEqual(@as(i32, 42), list.pop()); } Me gusta, ¬øC√≥mo aprendo? üìöüí° La documentaci√≥n oficial de Zig es un excelente punto de partida. Puedes acceder a ella en el sitio web oficial de Zig y encontrar√°s una gu√≠a detallada, ejemplos de c√≥digo, tutoriales y una descripci√≥n completa de la biblioteca est√°ndar. La documentaci√≥n oficial es constantemente actualizada y es una fuente confiable para comprender la sintaxis, las caracter√≠sticas del lenguaje y las mejores pr√°cticas. Recuerda, consulta siempre la documentaci√≥n de la versi√≥n de Zig que est√©s utilizando, porque puede variar mucho de una a otra.\nEl repositorio oficial de Zig en GitHub es una fuente invaluable de c√≥digo fuente abierto en Zig. Puedes explorar proyectos de la comunidad, estudiar el c√≥digo existente y aprender de ejemplos pr√°cticos. Tambi√©n puedes contribuir a proyectos existentes o incluso iniciar tus propios proyectos en Zig.\nAdem√°s de GitHub, el subreddit de Zig y el canal de Discord oficial de Zig son excelentes lugares para conectarte con otros programadores de Zig, hacer preguntas, compartir conocimientos y obtener ayuda. Estos espacios de la comunidad est√°n llenos de personas amigables y conocedoras que est√°n dispuestas a ayudarte en tu viaje de aprendizaje en Zig.\nRecuerda que la pr√°ctica es fundamental para dominar cualquier lenguaje de programaci√≥n. A medida que adquieras conocimientos, te recomiendo implementar proyectos peque√±os y desafiantes por tu cuenta. Esto te permitir√° aplicar lo que has aprendido, experimentar con difer\nY por supuesto ¬°sigue este blog!. Te llevar√© a un emocionante viaje a trav√©s del mundo de Zig. Compartir√© tutoriales, consejos √∫tiles, trucos y experiencias personales mientras exploramos juntos las maravillas y desaf√≠os de este incre√≠ble lenguaje de programaci√≥n. Desde los conceptos b√°sicos hasta t√©cnicas avanzadas, encontrar√°s contenido fresco y relevante para mejorar tus habilidades en Zig.\nAhora empieza todo ¬°No te pierdas ninguno de los nuevos art√≠culos de \u0026ldquo;Zig-zagueando\u0026rdquo;! Puedes suscribirte al blog mediante el cl√°sico y eficiente RSS üì∞ para recibir notificaciones cada vez que publique una nueva entrada. Adem√°s, te invito a participar en los comentarios, compartir tus propias experiencias y hacer preguntas sobre cualquier tema relacionado con Zig.\n¬°Prep√°rate para disfrutar de un blog lleno de conocimientos, diversi√≥n y aventuras en Zig! ¬°Nos vemos, valiente programador!\n","permalink":"https://d4c7.github.io/zig-zagueando/posts/zig-un-lenguaje-de-programaci%C3%B3n-simple-y-potente/","summary":"¬°Bienvenido al emocionante mundo de Zig! üöÄ Si est√°s buscando un lenguaje de programaci√≥n que combine eficiencia, seguridad y un enfoque en el rendimiento, ¬°has llegado al lugar correcto!\n¬øPor qu√© Zig? üéØ Una de las primeras cosas que notar√°s al explorar Zig es su enfoque en la seguridad y la prevenci√≥n de errores. El compilador de Zig es estricto y te ayudar√° a detectar problemas en tiempo de compilaci√≥n antes de que se conviertan en pesadillas en tiempo de ejecuci√≥n.","title":"Zig: Un lenguaje de programaci√≥n simple y potente üöÄ"}]